<!DOCTYPE html>


<html lang="zh-hanzi" >


<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="不要尽力而为，而要全力以赴，即使没有出色的外表和能力，也要压倒一切的霸气，用自己的光，照亮自己的路。" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     恁村扛把子
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/dist/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/fangsong0517/fangsong0517.github.io"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">恁村扛把子</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-Mynotes/计算机网络/SMTP、POP3、IMAP协议" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/14/Mynotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/SMTP%E3%80%81POP3%E3%80%81IMAP%E5%8D%8F%E8%AE%AE/"
    >Mynotes/计算机网络/SMTP、POP3、IMAP协议</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/14/Mynotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/SMTP%E3%80%81POP3%E3%80%81IMAP%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2020-05-13T18:05:21.895Z" itemprop="datePublished">2020-05-13</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="SMTP、POP3、IMAP协议"><a href="#SMTP、POP3、IMAP协议" class="headerlink" title="SMTP、POP3、IMAP协议"></a>SMTP、POP3、IMAP协议</h1><p>电子邮件协议</p>
<h2 id="SMTP简单邮件传输协议"><a href="#SMTP简单邮件传输协议" class="headerlink" title="SMTP简单邮件传输协议"></a>SMTP简单邮件传输协议</h2><p>SMTP的全称是“Simple Mail Transfer Protocol”，即简单邮件传输协议（25号端口）。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。</p>
<p>　　SMTP是一个“推”的协议，它不允许根据需要从远程服务器上“拉”来消息。SMTP服务器就是遵循SMTP协议的发送邮件服务器，SMTP认证就是要求必须在提供了账户名和密码之后才可以登录 SMTP 服务器，这就使得那些垃圾邮件的散播者无可乘之机。</p>
<p>SMTP已是事实上的E-Mail传输的标准。</p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gef8wjqpiaj30ry07wn0a.jpg" alt="image.png"></p>
<h2 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h2><p>　　IMAP全称是Internet Mail Access Protocol，即交互式邮件访问协议，是一个应用层协议（端口是143）。用来从本地邮件客户端（Outlook Express、Foxmail、Mozilla Thunderbird等）访问远程服务器上的邮件。</p>
<h2 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h2><p>　　POP3是Post Office Protocol 3的简称，即邮局协议的第3个版本，是TCP/IP协议族中的一员（默认端口是110）。本协议主要用于支持使用客户端远程管理在服务器上的电子邮件。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Mynotes/计算机网络/HTTP协议与HTTPS协议" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/14/Mynotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTPS%E5%8D%8F%E8%AE%AE/"
    >Mynotes/计算机网络/HTTP协议与HTTPS协议</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/14/Mynotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTPS%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2020-05-13T18:05:21.861Z" itemprop="datePublished">2020-05-13</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="HTTP协议与HTTPS协议"><a href="#HTTP协议与HTTPS协议" class="headerlink" title="HTTP协议与HTTPS协议"></a>HTTP协议与HTTPS协议</h1><h5 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP?"></a>什么是HTTP?</h5><blockquote>
<p>超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。</p>
</blockquote>
<p>什么是HTTPS？</p>
<blockquote>
<p>《图解HTTP》这本书中曾提过HTTPS是身披SSL外壳的HTTP。HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。</p>
<p>PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1geed3bdeiwj30oe08jmye.jpg" alt="image.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1geed5pugvzj30n709rtf9.jpg" alt="image.png"></p>
<table>
<thead>
<tr>
<th>版本</th>
<th>产生时间</th>
<th>内容</th>
<th>发展现状</th>
</tr>
</thead>
<tbody><tr>
<td>HTTP/0.9</td>
<td>1991年</td>
<td>不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求</td>
<td>没有作为正式的标准</td>
</tr>
<tr>
<td>HTTP/1.0</td>
<td>1996年</td>
<td>传输内容格式不限制，增加PUT、PATCH、HEAD、 OPTIONS、DELETE命令</td>
<td>正式作为标准</td>
</tr>
<tr>
<td>HTTP/1.1</td>
<td>1997年</td>
<td>持久连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码</td>
<td>2015年前使用最广泛</td>
</tr>
<tr>
<td>HTTP/2</td>
<td>2015年</td>
<td>多路复用、服务器推送、头信息压缩、二进制协议等</td>
<td>逐渐覆盖市场</td>
</tr>
</tbody></table>
<p><img src="https://img-blog.csdn.net/20180723103857872?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9taW5nMTAwMDAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述">这个Akamai公司建立的一个官方的演示，使用HTTP/1.1和HTTP/2同时请求379张图片，观察请求的时间，明显看出HTTP/2性能占优势。</p>
<p><img src="https://img-blog.csdn.net/20180723105652242?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9taW5nMTAwMDAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>多路复用：通过单一的HTTP/2连接请求发起多重的请求-响应消息，多个请求stream共享一个TCP连接，实现多留并行而不是依赖建立多个TCP连接。</p>
<h5 id="HTTP特点："><a href="#HTTP特点：" class="headerlink" title="HTTP特点："></a>HTTP特点：</h5><ol>
<li>无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作</li>
<li>无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。</li>
<li>基于请求和响应：基本的特性，由客户端发起请求，服务端响应</li>
<li>简单快速、灵活</li>
<li>通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性</li>
</ol>
<p>而且HTTPS有如下特点：</p>
<ol>
<li>内容加密：采用混合加密技术，中间者无法直接查看明文内容</li>
<li>验证身份：通过证书认证客户端访问的是自己的服务器</li>
<li>保护数据完整性：防止传输的内容被中间人冒充或者篡改</li>
</ol>
<p><img src="https://img-blog.csdn.net/20180719103559793?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9taW5nMTAwMDAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="内容加密和数据完整性保护"></p>
<p>摘录:<a href="https://blog.csdn.net/xiaoming100001/article/details/81109617" target="_blank" rel="noopener">https://blog.csdn.net/xiaoming100001/article/details/81109617</a></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Mynotes/计算机网络/IP地址、MAC地址、ARP地址" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/14/Mynotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E5%9C%B0%E5%9D%80%E3%80%81MAC%E5%9C%B0%E5%9D%80%E3%80%81ARP%E5%9C%B0%E5%9D%80/"
    >Mynotes/计算机网络/IP地址、MAC地址、ARP地址</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/14/Mynotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E5%9C%B0%E5%9D%80%E3%80%81MAC%E5%9C%B0%E5%9D%80%E3%80%81ARP%E5%9C%B0%E5%9D%80/" class="article-date">
  <time datetime="2020-05-13T18:05:21.861Z" itemprop="datePublished">2020-05-13</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="IP地址、MAC地址、ARP地址"><a href="#IP地址、MAC地址、ARP地址" class="headerlink" title="IP地址、MAC地址、ARP地址"></a>IP地址、MAC地址、ARP地址</h1><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>属于网络层</p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gehr2wwz4mj30ql0b1q6t.jpg" alt="image.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gehs64gnzrj30lf0a6juz.jpg" alt="image.png"></p>
<h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h3><p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gehrasln3pj30ir06mabf.jpg" alt="image.png"></p>
<p>192.168.0.1是C类，拿出192，二进制为1100 0000看出是C类</p>
<p>192.168.0.24/24 </p>
<p>255.255.255.255 C类地址的掩码，通过其与进行判断两个子网</p>
<h3 id="IP地址的作用"><a href="#IP地址的作用" class="headerlink" title="IP地址的作用"></a>IP地址的作用</h3><p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gehu1fjrqcj30li0a0dkh.jpg" alt="image.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gehu4egz08j30lh0bwae2.jpg" alt="image.png"></p>
<h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gehr4ua8qqj30r109p773.jpg" alt="image.png"></p>
<p><code>MAC</code>地址属于硬件的，软件层面可以建立一个虚拟<code>MAC</code>地址，<code>ARP</code>协议是将<code>IP</code>地址转化为<code>MAC</code>地址</p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gehsn4635ij30lh0c10vk.jpg" alt="image.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gehspn79isj30ld0bwdjt.jpg" alt="image.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gehsqtd8zbj30lm09077l.jpg" alt="image.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gehstdz9uwj30ld0b377m.jpg" alt="image.png"></p>
<h3 id="ARP协议的作用"><a href="#ARP协议的作用" class="headerlink" title="ARP协议的作用"></a>ARP协议的作用</h3><p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gehrri8bxlj30n50adjso.jpg" alt="image.png"></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Mynotes/计算机网络/FTP协议" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/14/Mynotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/FTP%E5%8D%8F%E8%AE%AE/"
    >Mynotes/计算机网络/FTP协议</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/14/Mynotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/FTP%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2020-05-13T18:05:21.856Z" itemprop="datePublished">2020-05-13</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h1><p>是 TCP/IP 协议组中的协议之一(文件传输协议)</p>
<p>FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端。</p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gef8p5iii9j30sb0aoq6q.jpg" alt="image.png"></p>
<h2 id="FTP命令和回答"><a href="#FTP命令和回答" class="headerlink" title="FTP命令和回答"></a>FTP命令和回答</h2><p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gef8r9jy2jj30gh060q4r.jpg" alt="image.png"></p>
<h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gef8s6guz9j30lj04qac2.jpg" alt="image.png"></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Mynotes/计算机网络/DNS协议" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/14/Mynotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E5%8D%8F%E8%AE%AE/"
    >Mynotes/计算机网络/DNS协议</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/14/Mynotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2020-05-13T18:05:21.855Z" itemprop="datePublished">2020-05-13</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h1><p>域名转IP</p>
<ul>
<li><p>中文名</p>
<p>域名解析协议</p>
</li>
<li><p>外文名</p>
<p>DNS protocol</p>
</li>
<li><p>作  用</p>
<p>完成域名地址与IP地址的转换</p>
</li>
</ul>
<h2 id="1、-什么是DNS协议？"><a href="#1、-什么是DNS协议？" class="headerlink" title="1、 什么是DNS协议？"></a>1、 什么是DNS协议？</h2><p>&lt;1&gt;DNS协议就是用来将域名解析到IP地址的一种协议，当然，也可以将IP地址转换为域名的一种协议。<br>&lt;2&gt;DNS协议基于UDP和TCP协议的，端口号53，用户到服务器采用UDP，DNS服务器通信采用TCP<br>&lt;3&gt;大型运营商、互联网机构等会向公众提供免费的DNS服务，例如，谷歌的8.8.8.8 8.8.4.4 阿里巴巴223.5.5.5 223.6.6.6<br>&lt;4&gt;如果DNS服务器down掉了，那么你只能通过IP地址来访问服务了。<br>&lt;5&gt;我们从以下几部分来理解DNS协议：</p>
<ul>
<li>域名结构</li>
<li>域名服务器</li>
</ul>
<h2 id="2、域名结构"><a href="#2、域名结构" class="headerlink" title="2、域名结构"></a>2、域名结构</h2><p>像Linux目录结构一样，现代因特网采用层次树状结构的命名方法，任何一个连接在因特网上的主机或路由器，都有一个唯一的层次结构的名字，该名字称为域名。域名查询</p>
<p><img src="https://img-blog.csdn.net/20180105145627203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamluOTcwNTA1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<blockquote>
<p>国家顶级域名：中国:cn， 美国:us，英国uk…    </p>
<p>通用顶级域名：com 公司企业  edu教育机构 gov政府部门  int国际组织  mil军事部门  net网络 org非盈利组织…    </p>
<p>反向域名：只有一个arpa，用于PTR查询（IP地址转换为域名） 。</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gef9bj5hfsj30se0gvwjd.jpg" alt="image.png"></p>
<h2 id="3、DNS污染"><a href="#3、DNS污染" class="headerlink" title="3、DNS污染"></a>3、DNS污染</h2><p><strong>网域服务器缓存污染</strong>（DNS cache pollution），又称<strong>域名服务器缓存投毒</strong>（DNS cache poisoning），是指一些刻意制造或无意中制造出来的域名服务器<a href="https://baike.baidu.com/item/数据包" target="_blank" rel="noopener">数据包</a>，把域名指往不正确的IP地址。一般来说，在<a href="https://baike.baidu.com/item/互联网" target="_blank" rel="noopener">互联网</a>上都有可信赖的网域服务器，但为减低网络上的流量压力，一般的域名服务器都会把从上游的域名服务器获得的解析记录暂存起来，待下次有其他机器要求解析域名时，可以立即提供服务。一旦有关网域的局域域名服务器的缓存受到污染，就会把网域内的计算机导引往错误的服务器或服务器的网址。</p>
<p>某些<a href="https://baike.baidu.com/item/网络运营商" target="_blank" rel="noopener">网络运营商</a>为了某些目的，对<a href="https://baike.baidu.com/item/DNS/427444" target="_blank" rel="noopener">DNS</a>进行了某些操作，导致使用<a href="https://baike.baidu.com/item/ISP/10152" target="_blank" rel="noopener">ISP</a>的正常上网设置无法通过域名取得正确的IP地址。</p>
<p>某些国家或地区出于某些目的为了防止某网站被访问，而且其又掌握部分国际DNS根目录服务器或镜像，也会利用此方法进行屏蔽。</p>
<p>常用的手段有：<a href="https://baike.baidu.com/item/DNS劫持" target="_blank" rel="noopener">DNS劫持</a>和DNS污染。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Mynotes/操作系统与系统编程/理解select、poll和epoll区别/理解select、poll和epoll区别" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/14/Mynotes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%90%86%E8%A7%A3select%E3%80%81poll%E5%92%8Cepoll%E5%8C%BA%E5%88%AB/%E7%90%86%E8%A7%A3select%E3%80%81poll%E5%92%8Cepoll%E5%8C%BA%E5%88%AB/"
    >Mynotes/操作系统与系统编程/理解select、poll和epoll区别/理解select、poll和epoll区别</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/14/Mynotes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%90%86%E8%A7%A3select%E3%80%81poll%E5%92%8Cepoll%E5%8C%BA%E5%88%AB/%E7%90%86%E8%A7%A3select%E3%80%81poll%E5%92%8Cepoll%E5%8C%BA%E5%88%AB/" class="article-date">
  <time datetime="2020-05-13T18:05:21.825Z" itemprop="datePublished">2020-05-13</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="理解select、poll和epoll区别"><a href="#理解select、poll和epoll区别" class="headerlink" title="理解select、poll和epoll区别"></a>理解select、poll和epoll区别</h1><h2 id="１、IO复用模型"><a href="#１、IO复用模型" class="headerlink" title="１、IO复用模型"></a>１、IO复用模型</h2><p><img src="https://static.dingtalk.com/media/lALPDiQ3KR9S0PHNApTNA5Q_916_660.png_620x10000q90g.jpg?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%22627064533%3A627064533%22%2C%22msgId%22%3A%223484896791903%22%7D&bizType=im&open_id=627064533" alt="图片"></p>
<h2 id="２、目前的常用的IO复用模型有三种：select，poll，epoll"><a href="#２、目前的常用的IO复用模型有三种：select，poll，epoll" class="headerlink" title="２、目前的常用的IO复用模型有三种：select，poll，epoll"></a>２、目前的常用的IO复用模型有三种：select，poll，epoll</h2><p>(1)select时间复杂度O(n)</p>
<p>他仅仅知道有I/O事件发生了，却不知道是哪那几个流(可能有一个，多个，甚至全部),我们只能无差别轮询所有的流，找出能读出数据，或者能写入数据的流，对他们进行操作。所以<font color = red>select具有o(n)无差别轮询的时间复杂度</font>，同时处理的流越多，无差别轮询时间就越长。</p>
<p>(2)poll时间复杂度O(n)</p>
<p>poll本质上与select没有区别,他讲用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，但是<font color = red>它没有最大连接的限制</font>，原因是它给予链表来存储的。</p>
<p>(3)epoll时间复杂度O(1)</p>
<p>epoll可以理解为evnt poll, 不同于忙轮训和无差别轮训,epoll会把那个流发生怎样的I/O时间通知我们。所以我们说epoll实际上是<font color = red>事件驱动(每个事件关联上fd)</font>的，此时我们对这些流的操作都是有意义的,它是红黑树,(复杂度降到了O(1));</p>
<p>select, poll, epoll 都是IO多路复用机制。I/O多路复用就是通过这种机制，可以监视多个描述度，一旦某个描述符就绪(一般是读就绪或者写就绪)，能够通知程序进行相应的读写操作。但select,poll,epoll本质上都是I/O,因为他们都需要在读写时间就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责吧数据从内核拷贝到用户空间。</p>
<p>epoll跟select都能提供多路I/O服用的解决方案。在现在的Linux内核中都能够支持，其中epoll是linux所特有，而select则应该是POSIX所规定,一般操作系统均有实现;</p>
<h2 id="３、select、poll、epoll-区别总结："><a href="#３、select、poll、epoll-区别总结：" class="headerlink" title="３、select、poll、epoll 区别总结："></a>３、<strong>select、poll、epoll 区别总结：</strong></h2><h3 id="3-1、支持一个进程所能打开的最大连接数"><a href="#3-1、支持一个进程所能打开的最大连接数" class="headerlink" title="3.1、支持一个进程所能打开的最大连接数"></a>3.1、支持一个进程所能打开的<font color = red>最大连接数</font></h3><p>select：单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32×32，同理64位机器上FD_SETSIZE为32×64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</p>
<p>poll：poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的。</p>
<p>epoll：虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接。</p>
<h3 id="3-2、FD剧增后带来的IO效率问题"><a href="#3-2、FD剧增后带来的IO效率问题" class="headerlink" title="3.2、FD剧增后带来的IO效率问题"></a>3.2、FD剧增后带来的IO<font color = red>效率问题</font></h3><p>select：因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</p>
<p>poll:    同上。</p>
<p>epoll:    因为epoll内核中实现是根据每个fd上的callback函数实现的，只有活跃的socket才会主动调用callback,所以在活跃socket较少的情况下,使用epoll没有前面两者线性下降的性能问题，但是所有的sockfd都在活跃情况下，可能会出现性能问题。</p>
<h3 id="3-3、消息传递方式"><a href="#3-3、消息传递方式" class="headerlink" title="3.3、消息传递方式"></a>3.3、<font color = red>消息传递方式</font></h3><p>select：内核需要将消息传递到用户空间，都需要内核拷贝动作</p>
<p>poll：同上</p>
<p>epoll：epoll通过内核和用户空间共享一块内存来实现的。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><p>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。</p>
<p><strong>1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调</strong></p>
<p><strong>2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善</strong> </p>
<p><img src="https://static.dingtalk.com/media/lALPDhJzr-nhBnbNApPNA8U_965_659.png_620x10000q90g.jpg?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%22627064533%3A627064533%22%2C%22msgId%22%3A%223485696508656%22%7D&bizType=im&open_id=627064533" alt="图片"></p>
<img src="https://static.dingtalk.com/media/lALPDiCpqpJJGZLNAY7NA84_974_398.png_620x10000q90g.jpg?auth_bizType=IM&amp;auth_bizEntity=%7B%22cid%22%3A%22627064533%3A627064533%22%2C%22msgId%22%3A%223505296142785%22%7D&amp;bizType=im&amp;open_id=627064533" alt="图片" style="zoom:150%;" />


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Mynotes/操作系统与系统编程/理解select、poll和epoll区别/README" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/14/Mynotes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%90%86%E8%A7%A3select%E3%80%81poll%E5%92%8Cepoll%E5%8C%BA%E5%88%AB/README/"
    >Mynotes/操作系统与系统编程/理解select、poll和epoll区别/README</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/14/Mynotes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%90%86%E8%A7%A3select%E3%80%81poll%E5%92%8Cepoll%E5%8C%BA%E5%88%AB/README/" class="article-date">
  <time datetime="2020-05-13T18:05:21.824Z" itemprop="datePublished">2020-05-13</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="理解select、poll和epoll区别"><a href="#理解select、poll和epoll区别" class="headerlink" title="理解select、poll和epoll区别"></a>理解select、poll和epoll区别</h1><h2 id="１、IO复用模型"><a href="#１、IO复用模型" class="headerlink" title="１、IO复用模型"></a>１、IO复用模型</h2><p><img src="https://static.dingtalk.com/media/lALPDiQ3KR9S0PHNApTNA5Q_916_660.png_620x10000q90g.jpg?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%22627064533%3A627064533%22%2C%22msgId%22%3A%223484896791903%22%7D&bizType=im&open_id=627064533" alt="图片"></p>
<h2 id="２、目前的常用的IO复用模型有三种：select，poll，epoll"><a href="#２、目前的常用的IO复用模型有三种：select，poll，epoll" class="headerlink" title="２、目前的常用的IO复用模型有三种：select，poll，epoll"></a>２、目前的常用的IO复用模型有三种：select，poll，epoll</h2><p>(1)select时间复杂度O(n)</p>
<p>他仅仅知道有I/O事件发生了，却不知道是哪那几个流(可能有一个，多个，甚至全部),我们只能无差别轮询所有的流，找出能读出数据，或者能写入数据的流，对他们进行操作。所以<font color = red>select具有o(n)无差别轮询的时间复杂度</font>，同时处理的流越多，无差别轮询时间就越长。</p>
<p>(2)poll时间复杂度O(n)</p>
<p>poll本质上与select没有区别,他讲用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，但是<font color = red>它没有最大连接的限制</font>，原因是它给予链表来存储的。</p>
<p>(3)epoll时间复杂度O(1)</p>
<p>epoll可以理解为evnt poll, 不同于忙轮训和无差别轮训,epoll会把那个流发生怎样的I/O时间通知我们。所以我们说epoll实际上是<font color = red>事件驱动(每个事件关联上fd)</font>的，此时我们对这些流的操作都是有意义的,它是红黑树,(复杂度降到了O(1));</p>
<p>select, poll, epoll 都是IO多路复用机制。I/O多路复用就是通过这种机制，可以监视多个描述度，一旦某个描述符就绪(一般是读就绪或者写就绪)，能够通知程序进行相应的读写操作。但select,poll,epoll本质上都是I/O,因为他们都需要在读写时间就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责吧数据从内核拷贝到用户空间。</p>
<p>epoll跟select都能提供多路I/O服用的解决方案。在现在的Linux内核中都能够支持，其中epoll是linux所特有，而select则应该是POSIX所规定,一般操作系统均有实现;</p>
<h2 id="３、select、poll、epoll-区别总结："><a href="#３、select、poll、epoll-区别总结：" class="headerlink" title="３、select、poll、epoll 区别总结："></a>３、<strong>select、poll、epoll 区别总结：</strong></h2><h3 id="3-1、支持一个进程所能打开的最大连接数"><a href="#3-1、支持一个进程所能打开的最大连接数" class="headerlink" title="3.1、支持一个进程所能打开的最大连接数"></a>3.1、支持一个进程所能打开的<font color = red>最大连接数</font></h3><p>select：单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32×32，同理64位机器上FD_SETSIZE为32×64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</p>
<p>poll：poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的。</p>
<p>epoll：虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接。</p>
<h3 id="3-2、FD剧增后带来的IO效率问题"><a href="#3-2、FD剧增后带来的IO效率问题" class="headerlink" title="3.2、FD剧增后带来的IO效率问题"></a>3.2、FD剧增后带来的IO<font color = red>效率问题</font></h3><p>select：因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</p>
<p>poll:    同上。</p>
<p>epoll:    因为epoll内核中实现是根据每个fd上的callback函数实现的，只有活跃的socket才会主动调用callback,所以在活跃socket较少的情况下,使用epoll没有前面两者线性下降的性能问题，但是所有的sockfd都在活跃情况下，可能会出现性能问题。</p>
<h3 id="3-3、消息传递方式"><a href="#3-3、消息传递方式" class="headerlink" title="3.3、消息传递方式"></a>3.3、<font color = red>消息传递方式</font></h3><p>select：内核需要将消息传递到用户空间，都需要内核拷贝动作</p>
<p>poll：同上</p>
<p>epoll：epoll通过内核和用户空间共享一块内存来实现的。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><p>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。</p>
<p><strong>1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调</strong></p>
<p><strong>2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善</strong> </p>
<p><img src="https://static.dingtalk.com/media/lALPDhJzr-nhBnbNApPNA8U_965_659.png_620x10000q90g.jpg?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%22627064533%3A627064533%22%2C%22msgId%22%3A%223485696508656%22%7D&bizType=im&open_id=627064533" alt="图片"></p>
<img src="https://static.dingtalk.com/media/lALPDiCpqpJJGZLNAY7NA84_974_398.png_620x10000q90g.jpg?auth_bizType=IM&amp;auth_bizEntity=%7B%22cid%22%3A%22627064533%3A627064533%22%2C%22msgId%22%3A%223505296142785%22%7D&amp;bizType=im&amp;open_id=627064533" alt="图片" style="zoom:150%;" />


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Mynotes/操作系统与系统编程/消息队列/README" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/14/Mynotes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/README/"
    >Mynotes/操作系统与系统编程/消息队列/README</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/14/Mynotes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/README/" class="article-date">
  <time datetime="2020-05-13T18:05:21.823Z" itemprop="datePublished">2020-05-13</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><blockquote>
<p>消息队列函数由<code>msgget</code>、<code>msgctl</code>、<code>msgsnd</code>、<code>msgrcv</code>四个函数组成。下面的表格列出了这四个函数的函数原型及其具体说明。</p>
</blockquote>
<h4 id="1-msgget函数原型"><a href="#1-msgget函数原型" class="headerlink" title="1.  msgget函数原型"></a>1.  <code>msgget</code>函数原型</h4><table>
<thead>
<tr>
<th><code>msgget</code>(得到消息队列标识符或创建一个消息队列对象)</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>所需头文件</td>
<td><code>#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;</code></td>
<td></td>
</tr>
<tr>
<td>函数说明</td>
<td>得到消息队列标识符或创建一个消息队列对象并返回消息队列标识符</td>
<td></td>
</tr>
<tr>
<td>函数原型</td>
<td><code>int msgget(key_t key, int msgflg)</code></td>
<td></td>
</tr>
<tr>
<td>函数传入值</td>
<td>key</td>
<td>0(IPC_PRIVATE)：会建立新的消息队列</td>
</tr>
<tr>
<td>大于0的32位整数：视参数<code>msgflg</code>来确定操作。通常要求此值来源于<code>ftok</code>返回的<code>IPC</code>键值</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>msgflg</code></td>
<td>0：取消息队列标识符，若不存在则函数会报错</td>
<td></td>
</tr>
<tr>
<td><code>IPC_CREAT</code>：当<code>msgflg&amp;IPC_CREAT</code>为真时，如果内核中不存在键值与key相等的消息队列，则新建一个消息队列；如果存在这样的消息队列，返回此消息队列的标识符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>`IPC_CREAT</td>
<td>IPC_EXCL`：如果内核中不存在键值与key相等的消息队列，则新建一个消息队列；如果存在这样的消息队列则报错</td>
<td></td>
</tr>
<tr>
<td>函数返回值</td>
<td>成功：返回消息队列的标识符</td>
<td></td>
</tr>
<tr>
<td>出错：-1，错误原因存于error中</td>
<td></td>
<td></td>
</tr>
<tr>
<td>附加说明</td>
<td>上述<code>msgflg</code>参数为模式标志参数，使用时需要与<code>IPC</code>对象存取权限（如0600）进行|运算来确定消息队列的存取权限</td>
<td></td>
</tr>
<tr>
<td>错误代码</td>
<td><code>EACCES</code>：指定的消息队列已存在，但调用进程没有权限访问它<code>EEXIST：key</code>指定的消息队列已存在，而<code>msgflg</code>中同时指定<code>IPC_CREAT</code>和<code>IPC_EXCL</code>标志<code>ENOENT：key</code>指定的消息队列不存在同时<code>msgflg</code>中没有指定<code>IPC_CREAT标志``ENOMEM</code>：需要建立消息队列，但内存不足<code>ENOSPC</code>：需要建立消息队列，但已达到系统的限制</td>
<td></td>
</tr>
</tbody></table>
<p>如果用msgget创建了一个新的消息队列对象时，则msqid_ds结构成员变量的值设置如下：</p>
<p>​    msg_qnum、msg_lspid、msg_lrpid、 msg_stime、msg_rtime设置为0。</p>
<p>​    msg_ctime设置为当前时间。</p>
<p>​    msg_qbytes设成系统的限制值。</p>
<p>​    msgflg的读写权限写入msg_perm.mode中。</p>
<p>​    msg_perm结构的uid和cuid成员被设置成当前进程的有效用户ID，gid和cuid成员被设置成当前进程的有效组ID。</p>
<h4 id="2-msgctl函数原型"><a href="#2-msgctl函数原型" class="headerlink" title="2.  msgctl函数原型"></a>2.  <code>msgctl</code>函数原型</h4><table>
<thead>
<tr>
<th>msgctl (获取和设置消息队列的属性)</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>所需头文件</td>
<td>#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;</td>
<td></td>
</tr>
<tr>
<td>函数说明</td>
<td>获取和设置消息队列的属性</td>
<td></td>
</tr>
<tr>
<td>函数原型</td>
<td>int msgctl(int msqid, int cmd, struct msqid_ds *buf)</td>
<td></td>
</tr>
<tr>
<td>函数传入值</td>
<td>msqid</td>
<td>消息队列标识符</td>
</tr>
<tr>
<td>cmd</td>
<td>IPC_STAT:获得msgid的消息队列头数据到buf中</td>
<td></td>
</tr>
<tr>
<td>IPC_SET：设置消息队列的属性，要设置的属性需先存储在buf中，可设置的属性包括：msg_perm.uid、msg_perm.gid、msg_perm.mode以及msg_qbytes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>buf：消息队列管理结构体，请参见消息队列内核结构说明部分</td>
<td></td>
<td></td>
</tr>
<tr>
<td>函数返回值</td>
<td>成功：0</td>
<td></td>
</tr>
<tr>
<td>出错：-1，错误原因存于error中</td>
<td></td>
<td></td>
</tr>
<tr>
<td>错误代码</td>
<td>EACCESS：参数cmd为IPC_STAT，确无权限读取该消息队列EFAULT：参数buf指向无效的内存地址EIDRM：标识符为msqid的消息队列已被删除EINVAL：无效的参数cmd或msqidEPERM：参数cmd为IPC_SET或IPC_RMID，却无足够的权限执行</td>
<td></td>
</tr>
</tbody></table>
<h4 id="3-msgsnd函数原型"><a href="#3-msgsnd函数原型" class="headerlink" title="3.  msgsnd函数原型"></a>3.  <code>msgsnd</code>函数原型</h4><table>
<thead>
<tr>
<th>msgsnd (将消息写入到消息队列)</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>所需头文件</td>
<td>#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;</td>
<td></td>
</tr>
<tr>
<td>函数说明</td>
<td>将msgp消息写入到标识符为msqid的消息队列</td>
<td></td>
</tr>
<tr>
<td>函数原型</td>
<td>int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg)</td>
<td></td>
</tr>
<tr>
<td>函数传入值</td>
<td>msqid</td>
<td>消息队列标识符</td>
</tr>
<tr>
<td>msgp</td>
<td>发送给队列的消息。msgp可以是任何类型的结构体，但第一个字段必须为long类型，即表明此发送消息的类型，msgrcv根据此接收消息。msgp定义的参照格式如下：  struct s_msg{ /<em>msgp定义的参照格式</em>/    long type; /* 必须大于0,消息类型 <em>/       char mtext[256]; /*消息正文，可以是其他任何类型</em>/   } msgp;</td>
<td></td>
</tr>
<tr>
<td>msgsz</td>
<td>要发送消息的大小，不含消息类型占用的4个字节,即mtext的长度</td>
<td></td>
</tr>
<tr>
<td>msgflg</td>
<td>0：当消息队列满时，msgsnd将会阻塞，直到消息能写进消息队列</td>
<td></td>
</tr>
<tr>
<td>IPC_NOWAIT：当消息队列已满的时候，msgsnd函数不等待立即返回</td>
<td></td>
<td></td>
</tr>
<tr>
<td>IPC_NOERROR：若发送的消息大于size字节，则把该消息截断，截断部分将被丢弃，且不通知发送进程。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>函数返回值</td>
<td>成功：0</td>
<td></td>
</tr>
<tr>
<td>出错：-1，错误原因存于error中</td>
<td></td>
<td></td>
</tr>
<tr>
<td>错误代码</td>
<td>EAGAIN：参数msgflg设为IPC_NOWAIT，而消息队列已满EIDRM：标识符为msqid的消息队列已被删除EACCESS：无权限写入消息队列EFAULT：参数msgp指向无效的内存地址EINTR：队列已满而处于等待情况下被信号中断EINVAL：无效的参数msqid、msgsz或参数消息类型type小于0</td>
<td></td>
</tr>
</tbody></table>
<p>  msgsnd()为阻塞函数，当消息队列容量满或消息个数满会阻塞。消息队列已被删除，则返回EIDRM错误；被信号中断返回E_INTR错误。</p>
<p> 如果设置IPC_NOWAIT消息队列满或个数满时会返回-1，并且置EAGAIN错误。</p>
<p>msgsnd()解除阻塞的条件有以下三个条件：</p>
<p>①  不满足消息队列满或个数满两个条件，即消息队列中有容纳该消息的空间。</p>
<p>②  msqid代表的消息队列被删除。</p>
<p>③  调用msgsnd函数的进程被信号中断。</p>
<h4 id="4-msgrcv函数原型"><a href="#4-msgrcv函数原型" class="headerlink" title="4. msgrcv函数原型"></a>4. <code>msgrcv</code>函数原型</h4><table>
<thead>
<tr>
<th>msgrcv (从消息队列读取消息)</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>所需头文件</td>
<td>#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;</td>
<td></td>
</tr>
<tr>
<td>函数说明</td>
<td>从标识符为msqid的消息队列读取消息并存于msgp中，读取后把此消息从消息队列中删除</td>
<td></td>
</tr>
<tr>
<td>函数原型</td>
<td>ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,           int msgflg);</td>
<td></td>
</tr>
<tr>
<td>函数传入值</td>
<td>msqid</td>
<td>消息队列标识符</td>
</tr>
<tr>
<td>msgp</td>
<td>存放消息的结构体，结构体类型要与msgsnd函数发送的类型相同</td>
<td></td>
</tr>
<tr>
<td>msgsz</td>
<td>要接收消息的大小，不含消息类型占用的4个字节</td>
<td></td>
</tr>
<tr>
<td>msgtyp</td>
<td>0：接收第一个消息</td>
<td></td>
</tr>
<tr>
<td>&gt;0：接收类型等于msgtyp的第一个消息</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&lt;0：接收类型等于或者小于msgtyp绝对值的第一个消息</td>
<td></td>
<td></td>
</tr>
<tr>
<td>msgflg</td>
<td>0: 阻塞式接收消息，没有该类型的消息msgrcv函数一直阻塞等待</td>
<td></td>
</tr>
<tr>
<td>IPC_NOWAIT：如果没有返回条件的消息调用立即返回，此时错误码为ENOMSG</td>
<td></td>
<td></td>
</tr>
<tr>
<td>IPC_EXCEPT：与msgtype配合使用返回队列中第一个类型不为msgtype的消息</td>
<td></td>
<td></td>
</tr>
<tr>
<td>IPC_NOERROR：如果队列中满足条件的消息内容大于所请求的size字节，则把该消息截断，截断部分将被丢弃</td>
<td></td>
<td></td>
</tr>
<tr>
<td>函数返回值</td>
<td>成功：实际读取到的消息数据长度</td>
<td></td>
</tr>
<tr>
<td>出错：-1，错误原因存于error中</td>
<td></td>
<td></td>
</tr>
<tr>
<td>错误代码</td>
<td>E2BIG：消息数据长度大于msgsz而msgflag没有设置IPC_NOERROREIDRM：标识符为msqid的消息队列已被删除EACCESS：无权限读取该消息队列EFAULT：参数msgp指向无效的内存地址ENOMSG：参数msgflg设为IPC_NOWAIT，而消息队列中无消息可读EINTR：等待读取队列内的消息情况下被信号中断</td>
<td></td>
</tr>
</tbody></table>
<p>msgrcv()解除阻塞的条件有以下三个：</p>
<p>①  消息队列中有了满足条件的消息。</p>
<p>②  msqid代表的消息队列被删除。</p>
<p>③  调用msgrcv()的进程被信号中断。</p>
<p>消息队列使用程序范例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: msg.c</span></span><br><span class="line"><span class="comment">	&gt; Author:fangsong</span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment">	&gt; Created Time: 2020年05月10日 星期日 16时52分54秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">80</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usage</span><span class="params">(<span class="keyword">char</span> *prog_name, <span class="keyword">char</span> *msg)</span> </span>&#123; <span class="comment">//出错函数</span></span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">fputs</span>(msg, <span class="built_in">stderr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s [options]\n"</span>, prog_name);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Options are:\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"-s        send message using msgsnd()\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"-r        read message using msgrcv()\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"-t        message type (default is 1)\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"-k        message queue key (default is 1234)\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send_msg</span><span class="params">(<span class="keyword">int</span> qid, <span class="keyword">int</span> msgtype)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">time_t</span> t;</span><br><span class="line"></span><br><span class="line">    msg.mtype = msgtype;</span><br><span class="line"></span><br><span class="line">    time(&amp;t);<span class="comment">//取时间</span></span><br><span class="line">    <span class="built_in">snprintf</span>(msg.mtext, <span class="keyword">sizeof</span>(msg.mtext), <span class="string">"a message at %s"</span>, </span><br><span class="line">             ctime(&amp;t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msgsnd(qid, (<span class="keyword">void</span> *) &amp;msg, <span class="keyword">sizeof</span>(msg.mtext),</span><br><span class="line">                IPC_NOWAIT) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"msgsnd error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sent: %s\n"</span>, msg.mtext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get_msg</span><span class="params">(<span class="keyword">int</span> qid, <span class="keyword">int</span> msgtype)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msgrcv(qid, (<span class="keyword">void</span> *) &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), msgtype,</span><br><span class="line">               MSG_NOERROR | IPC_NOWAIT) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != ENOMSG) &#123;</span><br><span class="line">            perror(<span class="string">"msgrcv"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No message available for msgrcv()\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"message received: %s\n"</span>, msg.mtext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> qid, opt;</span><br><span class="line">    <span class="keyword">int</span> mode = <span class="number">0</span>;               <span class="comment">/* 1 = send, 2 = receive */</span></span><br><span class="line">    <span class="keyword">int</span> msgtype = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> msgkey = <span class="number">1234</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">"srt:k:"</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">            mode = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">            mode = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line">            msgtype = atoi(optarg);</span><br><span class="line">            <span class="keyword">if</span> (msgtype &lt;= <span class="number">0</span>)</span><br><span class="line">                usage(argv[<span class="number">0</span>], <span class="string">"-t option must be greater than 0\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'k'</span>:</span><br><span class="line">            msgkey = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            usage(argv[<span class="number">0</span>], <span class="string">"Unrecognized option\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">        usage(argv[<span class="number">0</span>], <span class="string">"must use either -s or -r option\n"</span>);</span><br><span class="line"></span><br><span class="line">    qid = msgget(msgkey, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (qid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"msgget"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="number">2</span>)</span><br><span class="line">        get_msg(qid, msgtype);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        send_msg(qid, msgtype);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Mynotes/操作系统与系统编程/文件锁/文件锁" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/14/Mynotes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E6%96%87%E4%BB%B6%E9%94%81/%E6%96%87%E4%BB%B6%E9%94%81/"
    >Mynotes/操作系统与系统编程/文件锁/文件锁</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/14/Mynotes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E6%96%87%E4%BB%B6%E9%94%81/%E6%96%87%E4%BB%B6%E9%94%81/" class="article-date">
  <time datetime="2020-05-13T18:05:21.820Z" itemprop="datePublished">2020-05-13</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h3 id="flock-函数"><a href="#flock-函数" class="headerlink" title="flock()函数"></a>flock()函数</h3><p>####　定义与用法</p>
<p>​    flock()函数锁死那个或释放文件</p>
<p>如果成功，则返回true,失败返回false</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flock(file, lock, block);</span><br><span class="line">原型：<span class="function"><span class="keyword">int</span> <span class="title">flock</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> operation)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>file</p>
<ul>
<li><p>必须</p>
</li>
<li><p>规定要锁定或释放的一打开的文件</p>
</li>
</ul>
</li>
<li><p>lock</p>
<ul>
<li><p>必须</p>
</li>
<li><p>规定要使用那种锁定的类型</p>
</li>
<li><p>可能的值：</p>
</li>
</ul>
<p>​        LOCK_SH-共享锁定(读取的程序)。允许其他进程访问该文件</p>
<p>​        LOCK_EX-独占锁定(写入的程序)。防止其他进程访问该文件</p>
<p>​        LOCK_UN-释放一个共享锁定或独占锁定</p>
<p>​        LOCK_NB-锁定的情况下避免阻塞其他进程</p>
</li>
<li><p>block</p>
<ul>
<li><p>可选</p>
</li>
<li><p>若设置为１，则当进行锁定时阻塞其他的进程。</p>
</li>
</ul>
</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Mynotes/操作系统与系统编程/信号量/README" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/14/Mynotes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E4%BF%A1%E5%8F%B7%E9%87%8F/README/"
    >Mynotes/操作系统与系统编程/信号量/README</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/14/Mynotes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E4%BF%A1%E5%8F%B7%E9%87%8F/README/" class="article-date">
  <time datetime="2020-05-13T18:05:21.817Z" itemprop="datePublished">2020-05-13</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>目录：</p>
<ul>
<li><a href="#一、什么是信号量">一、什么是信号量</a></li>
</ul>
<h3 id="一、什么是信号量"><a href="#一、什么是信号量" class="headerlink" title="一、什么是信号量"></a><font color = red>一、什么是信号量</font></h3><p>为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。临界区域是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说信号量是用来调协进程对共享资源的访问的。</p>
<p>信号量是一个特殊的变量，程序对其访问都是原子操作，且只允许对它进行等待（即P(信号变量))和发送（即V(信号变量))信息操作。最简单的信号量是只能取0和1的变量，这也是信号量最常见的一种形式，叫做二进制信号量。而可以取多个正整数的信号量被称为通用信号量。这里主要讨论二进制信号量。</p>
<h3 id="二、信号量的工作原理"><a href="#二、信号量的工作原理" class="headerlink" title="二、信号量的工作原理"></a><font color = red>二、信号量的工作原理</font></h3><p>由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv),他们的行为是这样的：</p>
<p>P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行</p>
<p>V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1.</p>
<p>举个例子，就是两个进程共享信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。</p>
<h3 id="三、Linux的信号量机制"><a href="#三、Linux的信号量机制" class="headerlink" title="三、Linux的信号量机制"></a><font color = red>三、Linux的信号量机制</font></h3><p>Linux提供了一组精心设计的信号量接口来对信号进行操作，它们不只是针对二进制信号量，下面将会对这些函数进行介绍，但请注意，这些函数都是用来对成组的信号量值进行操作的。它们声明在头文件<code>sys/sem.h</code>中。</p>
<p><strong>1、<code>semget()</code>函数</strong></p>
<p>它的作用是创建一个新的信号量或取得一个已有的信号量，原型为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> num_sems, <span class="keyword">int</span> sem_flages)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数key是整数值（唯一非零），不相关的进程可以通过它访问一个信号量，它代表程序可能需要使用某个西园，程序对所有的信号量访问都是间接的，程序先通过调用<code>semget()</code>函数并提供一个键，再由系统生成一个相应的信号标识符（semget()函数的返回值），只有semget()函数才直接使用信号量键，所有其他的信号量函数使用由semget()函数返回的信号量标识符。如果多个程序使用相同的key值，key将负责协调工作。</p>
<p>第二个参数num_sems指定需要的信号量数目，它的值几乎总是1。</p>
<p>第三个参数sem_flags是一组标志，当想要当信号量不存在时创建一个新的信号量，可以和值IPC_CREAT做按位或操作。设置了IPC_CREAT标志后，即使给出的键是一个已有信号量的键，也不会产生错误。而IPC_CREAT | IPC_EXCL则可以创建一个新的，唯一的信号量，如果信号量已存在，返回一个错误。</p>
<p>semget()函数成功返回一个相应信号标识符（非零），失败返回-1.</p>
<p><strong>2、semop()函数</strong></p>
<p>它的作用是改变信号量的值，原型为：</p>
<blockquote>
<p>int semop(int sem_id, struct sembuf *sem_opa, size_t num_sem_ops);</p>
</blockquote>
<p>sem_id是由semget()返回的信号量标识符，sembuf结构的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`struct` `sembuf&#123;``  ``short` `sem_num; ``// 除非使用一组信号量，否则它为0``  ``short` `sem_op; ``// 信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，即P（等待）操作，``          ``// 一个是+1，即V（发送信号）操作。``  ``short` `sem_flg; ``// 通常为SEM_UNDO,使操作系统跟踪信号，``          ``// 并在进程没有释放该信号量而终止时，操作系统释放信号量``&#125;;`</span><br></pre></td></tr></table></figure>

<p><strong>3、semctl()函数</strong></p>
<p>该函数用来直接控制信号量信息，它的原型为：</p>
<blockquote>
<p>int semctl(int sem_id, int sem_num, int command, …);</p>
</blockquote>
<p>如果有第四个参数，它通常是一个union semum结构，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`union` `semun &#123;``  ``int` `val;``  ``struct` `semid_ds *buf;``  ``unsigned ``short` `*arry;``&#125;;`</span><br></pre></td></tr></table></figure>

<p>前两个参数与前面一个函数中的一样，command通常是下面两个值中的其中一个</p>
<p>SETVAL：用来把信号量初始化为一个已知的值。p 这个值通过union semun中的val成员设置，其作用是在信号量第一次使用前对它进行设置。</p>
<p>IPC_RMID：用于删除一个已经无需继续使用的信号量标识符。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        fangsong
      </li>
      <li>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="恁村扛把子"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>

<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>
<script src="/dist/main.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>



<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

  <script src="/js/clickLove.js"></script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=436514312&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>