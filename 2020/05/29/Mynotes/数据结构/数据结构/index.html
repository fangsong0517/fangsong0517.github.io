<!DOCTYPE html>


<html lang="zh-hanzi" >


<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="不要尽力而为，而要全力以赴，即使没有出色的外表和能力，也要压倒一切的霸气，用自己的光，照亮自己的路。" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    Mynotes/数据结构/数据结构 |  恁村扛把子
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/dist/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      <section class="outer">
  <article id="post-Mynotes/数据结构/数据结构" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Mynotes/数据结构/数据结构
</h1>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/29/Mynotes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2020-05-29T06:22:36.768Z" itemprop="datePublished">2020-05-29</time>
</a>
      
      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">14.2k字</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">72分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>[TOC]</p>
<ul>
<li><p><a href="#1顺序表">1.顺序表</a></p>
</li>
<li><p><a href="#2链表">2.链表</a></p>
<pre><code>[程序内部，内存内部](#程序内部内存内部)
[链表翻转：](#链表翻转)</code></pre></li>
<li><p><a href="#3.队列&栈">3.队列&amp;栈</a></p>
<pre><code>[（１）队列：先进先出](#１队列先进先出)
[（２）栈 ：后进先出](#２栈后进先出)
[&lt;strong&gt;循环队列：&lt;/strong&gt;](#循环队列)
[&lt;strong&gt;栈：&lt;/strong&gt;](#栈)
[栈的扩容：](#栈的扩容)</code></pre></li>
<li><p><a href="#4树与二叉树">4.树与二叉树</a></p>
<pre><code>[树的结构定义](#树的结构定义)
   [二叉树的存储](#二叉树的存储)
   [二叉树的遍历](#二叉树的遍历)
   [先序遍历](#先序遍历)
   [中序遍历](#中序遍历)
   [后序遍历](#后序遍历)
   [已知先序和中序求后序](#已知先序和中序求后序)
      [二叉树的线索化](#二叉树的线索化)
      [二叉树转广义表](#二叉树转广义表)
      [广义表转二叉树](#广义表转二叉树)</code></pre></li>
<li><p><a href="#５堆与优先队列">５.堆与优先队列</a></p>
<pre><code>[&lt;strong&gt;堆：&lt;/strong&gt;](#堆)
   [&lt;strong&gt;优先队列&lt;/strong&gt;](#优先队列)
   [堆排序：](#堆排序)</code></pre></li>
<li><p><a href="#６排序算法">６.排序算法</a></p>
<pre><code>[稳定排序](#稳定排序)
    [插入排序](#插入排序)
    [归并排序](#归并排序)
[不稳定排序](#不稳定排序)
   [选择排序](#选择排序)
   [二分查找](#二分查找)</code></pre></li>
<li><p><a href="#８哈希表">８.哈希表</a></p>
</li>
<li><p><a href="#９二叉排序树">９.二叉排序树</a></p>
<pre><code>[插入:](#插入)
[删除:](#删除)</code></pre></li>
<li><p><a href="#10森林与并查集">10.森林与并查集</a></p>
<pre><code>[QUICK-FIND算法](#quick-find算法)
[QUICK-UNION算法](#quick-union算法)
[WEIGHTED QYICK-UNION算法](#weighted-qyick-union算法)</code></pre></li>
<li><p><a href="#11.字符串匹配">11.字符串匹配</a></p>
</li>
</ul>
<p> 数据结构 ＝ 结构定义 ＋ 结构操作</p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gewz18xnubj30ye0a2n2m.jpg" alt=""></p>
<h2 id="1-顺序表"><a href="#1-顺序表" class="headerlink" title="1.顺序表"></a>1.顺序表</h2><p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gewz6xuwz9j30vz0beq5c.jpg" alt="undefined"></p>
<p>插入与删除两个操作</p>
<p>插入时：size = 9, length = 6, data_type = xxx</p>
<p>删除时：size = 9, length = 4, data_type = xxx</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> size, length;</span><br><span class="line">&#125;Vector;</span><br><span class="line"></span><br><span class="line"><span class="function">Vector *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;   <span class="comment">//初始化顺序表</span></span><br><span class="line">    Vector *vec = (Vector *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Vector));</span><br><span class="line">    vec-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    vec-&gt;size = n;</span><br><span class="line">    vec-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(Vector *vec, <span class="keyword">int</span> ind, <span class="keyword">int</span> val)</span> </span>&#123; <span class="comment">//插入</span></span><br><span class="line">    <span class="keyword">if</span>(vec == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind &lt; <span class="number">0</span> || ind &gt; vec-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(vec-&gt;length == vec-&gt;size)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = vec-&gt;length; i &gt; ind; i--) &#123; <span class="comment">// 因为下表从０开始的，所以这里移动后下表为ind~length;</span></span><br><span class="line">        vec-&gt;data[i] = vec-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vec-&gt;data[ind] = val;</span><br><span class="line">    vec-&gt;length += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erase</span><span class="params">(Vector *vec, <span class="keyword">int</span> ind)</span> </span>&#123;　<span class="comment">//　删除</span></span><br><span class="line">    <span class="keyword">if</span>(vec == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind &lt; <span class="number">0</span> || ind &gt;= vec-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ind + <span class="number">1</span>; i &lt; vec-&gt;length; i++) &#123; <span class="comment">// 删除后的下表从ｉｎｄ　＋　１开始往后都减１；</span></span><br><span class="line">        vec-&gt;data[i - <span class="number">1</span>] = vec-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vec-&gt;length-=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Vector *vec)</span> </span>&#123;　<span class="comment">//输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Vector(%d) = ["</span>, vec-&gt;length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec-&gt;length; i++) &#123;</span><br><span class="line">        <span class="function">i &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">", "</span>)</span></span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,vec-&gt;data[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"]\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Vector *vec)</span> </span>&#123;　<span class="comment">// 清空释放</span></span><br><span class="line">    <span class="keyword">if</span>(vec == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(vec-&gt;data);<span class="comment">//free数据域，再free指针 </span></span><br><span class="line">    <span class="built_in">free</span>(vec);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 20</span></span><br><span class="line">    <span class="keyword">int</span> op, ind, val;</span><br><span class="line">    Vector *vec = init(max_op);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">        op = rand() % <span class="number">2</span>;</span><br><span class="line">        ind = rand() % (vec-&gt;length + <span class="number">1</span>);</span><br><span class="line">        val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"insert %d at %d to Vector = %d\n"</span>,val, ind, insert(vec, ind, val));</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"earse item at %d from Vector = %d\n"</span>, ind, erase(vec, ind));</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            output(vec);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clear(vec);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩容：</p>
<p><code>realloc</code>:１．先划分空间　２．将ｐ里内容拷贝到ｑ中　３．free(p)释放原来空间<br>此时如果扩容不成的话 此时<code>vec-&gt;data = NULL</code>了，找不到索引！</p>
<p>bug : </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(Vector *vec)</span> </span>&#123;</span><br><span class="line">    vec-&gt;size *= <span class="number">2</span>;</span><br><span class="line">    vec-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">realloc</span>(vec-&gt;data, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * vec-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand2</span><span class="params">(Vector *vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> extr_size = vec-&gt;size;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">while</span>(extr_size) &#123;</span><br><span class="line">        p = (<span class="keyword">int</span> *)<span class="built_in">realloc</span>(vec-&gt;data, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (vec-&gt;size + extr_size));</span><br><span class="line">        <span class="keyword">if</span>(p)<span class="keyword">break</span>;</span><br><span class="line">        extr_size /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vec-&gt;data = p;</span><br><span class="line">    vec-&gt;size += extr_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand3</span><span class="params">(Vector *vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *old_data = vec-&gt;data;</span><br><span class="line">    vec-&gt;size *= <span class="number">2</span>;</span><br><span class="line">    vec-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * vec-&gt;size);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec-&gt;length; i++) &#123;</span><br><span class="line">        vec-&gt;data[i] = old_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(old_data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最终代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> size, length;</span><br><span class="line">&#125;Vector;</span><br><span class="line"></span><br><span class="line"><span class="function">Vector *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Vector *vec = (Vector *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Vector));</span><br><span class="line">    vec-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    vec-&gt;size = n;</span><br><span class="line">    vec-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(Vector *vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *old_data = vec-&gt;data;</span><br><span class="line">    vec-&gt;size *= <span class="number">2</span>;</span><br><span class="line">    vec-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * vec-&gt;size);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec-&gt;length; i++) &#123;</span><br><span class="line">        vec-&gt;data[i] = old_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(old_data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand2</span><span class="params">(Vector *vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> extr_size = vec-&gt;size;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">while</span>(extr_size) &#123;</span><br><span class="line">        p = (<span class="keyword">int</span> *)<span class="built_in">realloc</span>(vec-&gt;data, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (vec-&gt;size + extr_size));</span><br><span class="line">        <span class="keyword">if</span>(p)<span class="keyword">break</span>;</span><br><span class="line">        extr_size /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vec-&gt;data = p;</span><br><span class="line">    vec-&gt;size += extr_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(Vector *vec, <span class="keyword">int</span> ind, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vec == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind &lt; <span class="number">0</span> || ind &gt; vec-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(vec-&gt;length == vec-&gt;size) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!expand(vec)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"expand successfully ! size = %d\n"</span>, vec-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = vec-&gt;length; i &gt; ind; i--) &#123;</span><br><span class="line">        vec-&gt;data[i] = vec-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vec-&gt;data[ind] = val;</span><br><span class="line">    vec-&gt;length += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erase</span><span class="params">(Vector *vec, <span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vec == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind &lt; <span class="number">0</span> || ind &gt;= vec-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ind + <span class="number">1</span>; i &lt; vec-&gt;length; i++) &#123;</span><br><span class="line">        vec-&gt;data[i - <span class="number">1</span>] = vec-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vec-&gt;length-=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Vector *vec)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Vector(%d) = ["</span>, vec-&gt;length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec-&gt;length; i++) &#123;</span><br><span class="line">        <span class="function">i &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">", "</span>)</span></span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,vec-&gt;data[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"]\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Vector *vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vec == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(vec-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(vec);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 20</span></span><br><span class="line">    <span class="keyword">int</span> op, ind, val;</span><br><span class="line">    Vector *vec = init(max_op);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">        op = rand() % <span class="number">4</span>;</span><br><span class="line">        ind = rand() % (vec-&gt;length + <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line">        val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"insert %d at %d to Vector = %d\n"</span>,val, ind, insert(vec, ind, val));</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"earse item at %d from Vector = %d\n"</span>, ind, erase(vec, ind));</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            output(vec);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clear(vec);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h2><p> <img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gewzcakdbpj30mn09pjsu.jpg" alt="2020-02-11 18-17-34屏幕截图.png"></p>
<h5 id="程序内部，内存内部"><a href="#程序内部，内存内部" class="headerlink" title="程序内部，内存内部"></a>程序内部，内存内部</h5><p>指向head的指针，体现在内存内部，内存内部节点信息，内存内部（数据域，指针域）</p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gewz87gzujj30m9094acj.jpg" alt="undefined"></p>
<p>在单向循环链表中之所以把head看做整个单向循环链表的尾戒点，解决了插入在１号的前面走一圈的问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    ListNode head;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;List;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode *p = (ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    p-&gt;data = val;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List *<span class="title">getLinkList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List *l = (List *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">    l-&gt;head.next = <span class="literal">NULL</span>;</span><br><span class="line">    l-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(List *l,<span class="keyword">int</span> ind, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind &lt; <span class="number">0</span> || ind &gt; l-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ListNode *p = &amp;(l-&gt;head), *node = getNewNode(val);</span><br><span class="line">    <span class="keyword">while</span>(ind--) p = p-&gt;next;</span><br><span class="line">    node-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = node;</span><br><span class="line">    l-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erase</span><span class="params">(List *l, <span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind &lt; <span class="number">0</span> || ind &gt;= l-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ListNode *p = &amp;(l-&gt;head), *q;</span><br><span class="line">    <span class="keyword">while</span>(ind--) p = p-&gt;next;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    l-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(List *l)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"List(%d) = ["</span>, l-&gt;length);</span><br><span class="line">    <span class="keyword">for</span>(ListNode *p = l-&gt;head.next; p; p=p-&gt;next ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d-&gt;"</span>, p-&gt;data);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NULL]\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_ListNode</span><span class="params">(ListNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_list</span><span class="params">(List *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    ListNode *p = l-&gt;head.next, *q;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        clear_ListNode(p);</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(l);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 20</span></span><br><span class="line">    List *l = getLinkList();</span><br><span class="line">    <span class="keyword">int</span> op, ind, val;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">    op = rand() % <span class="number">4</span>;</span><br><span class="line">    ind = rand() % (l-&gt;length + <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line">    val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"insert %d at %d to list = %d\n"</span>, val, ind, insert(l, ind, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"earse item at %d from list = %d\n"</span>, ind, erase(l, ind));</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(l);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clear_list(l);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="链表翻转："><a href="#链表翻转：" class="headerlink" title="链表翻转："></a>链表翻转：</h5><p><img src="https://i.loli.net/2020/05/18/jPeCUNyAz91bH2Q.png" alt="2020-02-11 20-35-45屏幕截图.png"><br><img src="https://i.loli.net/2020/05/18/uN7JrBvYaW4hAiq.png" alt="2020-02-11 20-36-51屏幕截图.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    ListNode *p = l-&gt;head.next, *q;</span><br><span class="line">    l-&gt;head.next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        p-&gt;next = l-&gt;head.next;</span><br><span class="line">        l-&gt;head.next = p;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最终代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    ListNode head;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;List;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; <span class="comment">//初始化获取一个新的节点</span></span><br><span class="line">    ListNode *p = (ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    p-&gt;data = val;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List *<span class="title">getLinkList</span><span class="params">()</span> </span>&#123; <span class="comment">//初始化一个链表</span></span><br><span class="line">    List *l = (List *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">    l-&gt;head.next = <span class="literal">NULL</span>;</span><br><span class="line">    l-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(List *l,<span class="keyword">int</span> ind, <span class="keyword">int</span> val)</span> </span>&#123;　<span class="comment">//插入</span></span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind &lt; <span class="number">0</span> || ind &gt; l-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ListNode *p = &amp;(l-&gt;head), *node = getNewNode(val);</span><br><span class="line">    <span class="keyword">while</span>(ind--) p = p-&gt;next;</span><br><span class="line">    node-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = node;</span><br><span class="line">    l-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erase</span><span class="params">(List *l, <span class="keyword">int</span> ind)</span> </span>&#123;　<span class="comment">//删除</span></span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind &lt; <span class="number">0</span> || ind &gt;= l-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ListNode *p = &amp;(l-&gt;head), *q;</span><br><span class="line">    <span class="keyword">while</span>(ind--) p = p-&gt;next;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    l-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(List *l)</span> </span>&#123;　<span class="comment">//输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"List(%d) = ["</span>, l-&gt;length);</span><br><span class="line">    <span class="keyword">for</span>(ListNode *p = l-&gt;head.next; p; p=p-&gt;next ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d-&gt;"</span>, p-&gt;data);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NULL]\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List *l)</span> </span>&#123;　<span class="comment">// 翻转</span></span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    ListNode *p = l-&gt;head.next, *q;</span><br><span class="line">    l-&gt;head.next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        p-&gt;next = l-&gt;head.next;</span><br><span class="line">        l-&gt;head.next = p;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_ListNode</span><span class="params">(ListNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_list</span><span class="params">(List *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    ListNode *p = l-&gt;head.next, *q;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        clear_ListNode(p);</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(l);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 20</span></span><br><span class="line">    List *l = getLinkList();</span><br><span class="line">    <span class="keyword">int</span> op, ind, val;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">    op = rand() % <span class="number">4</span>;</span><br><span class="line">    ind = rand() % (l-&gt;length + <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line">    val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"insert %d at %d to list = %d\n"</span>, val, ind, insert(l, ind, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"reverse the list\n"</span>);</span><br><span class="line">                reverse(l);</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"earse item at %d from list = %d\n"</span>, ind, erase(l, ind));</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(l);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clear_list(l);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>拓展：（打印箭头）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    ListNode head;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode *p = (ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    p-&gt;data = val;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List *<span class="title">getLinkList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List *l = (List *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">    l-&gt;head.next = <span class="literal">NULL</span>;</span><br><span class="line">    l-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(List *l,<span class="keyword">int</span> ind, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind &lt; <span class="number">0</span> || ind &gt; l-&gt;length) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = ind;</span><br><span class="line">    ListNode *p = &amp;(l-&gt;head), *node = getNewNode(val);</span><br><span class="line">    <span class="keyword">while</span>(ind--) p = p-&gt;next;</span><br><span class="line">    node-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = node;</span><br><span class="line">    l-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erase</span><span class="params">(List *l, <span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind &lt; <span class="number">0</span> || ind &gt;= l-&gt;length) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = ind;</span><br><span class="line">    ListNode *p = &amp;(l-&gt;head), *q;</span><br><span class="line">    <span class="keyword">while</span>(ind--) p = p-&gt;next;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    l-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_search</span><span class="params">(List *l, <span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> offset = <span class="number">3</span>;</span><br><span class="line">    ListNode *p = l-&gt;head.next;</span><br><span class="line">    <span class="keyword">while</span>(ind != <span class="number">-1</span> &amp;&amp; p) &#123;</span><br><span class="line">        offset += <span class="built_in">sprintf</span>(str, <span class="string">"%d-&gt;"</span>, p-&gt;data);</span><br><span class="line">        ind -= <span class="number">1</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; offset; i++) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"^\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; offset; i++) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"|\n\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(List *l)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"head-&gt;"</span>);</span><br><span class="line">    <span class="keyword">for</span>(ListNode *p = l-&gt;head.next; p; p=p-&gt;next ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d-&gt;"</span>, p-&gt;data);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NULL\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_ListNode</span><span class="params">(ListNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_list</span><span class="params">(List *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    ListNode *p = l-&gt;head.next, *q;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        clear_ListNode(p);</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(l);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 20</span></span><br><span class="line">    List *l = getLinkList();</span><br><span class="line">    <span class="keyword">int</span> op, ind, val, flag;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">    op = rand() % <span class="number">4</span>;</span><br><span class="line">    ind = rand() % (l-&gt;length + <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line">    val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"insert %d at %d to list\n"</span>, val, ind);</span><br><span class="line">                flag = insert(l, ind, val);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"earse item at %d from list \n"</span>, ind);</span><br><span class="line">                flag = erase(l, ind);</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(l);</span><br><span class="line">        output_search(l, flag);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clear_list(l);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gewzqv1xtjj30cq044757.jpg" alt="2020-02-11 18-42-49屏幕截图.png"></p>
<p>##　3.队列&amp;栈</p>
<h4 id="（１）队列：先进先出"><a href="#（１）队列：先进先出" class="headerlink" title="（１）队列：先进先出"></a><strong>（１）队列：</strong>先进先出</h4><p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gewzrfse7nj30hf0afdgx.jpg" alt="2020-02-13 16-10-53屏幕截图.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gewzs5tbsaj30hi0ad765.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gewzs5tbn5j30ip0agtap.jpg" alt=""></p>
<p>队列假溢出：</p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gewzs5tklcj30m50adtb4.jpg" alt=""></p>
<p>1,2,3空间扔在，而当前插入不下，即为假溢出，有空间能插入；</p>
<p>如果队尾能指向第一个元素，则引入循环队列     －&gt;</p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gewzs5u7u9j30md0ayjt4.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gewzubk23uj30mv0b0juc.jpg" alt="循环队列.png"></p>
<p>主要思考　头２　尾３　元素个数４</p>
<h4 id="（２）栈-：后进先出"><a href="#（２）栈-：后进先出" class="headerlink" title="*（２）栈　*：后进先出"></a>*<em>（２）栈　*</em>：后进先出</h4><p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gewzv0d83hj30ny0agmyf.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gewzw8zszsj30le0b2jt4.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gewzxd1077j30kd0a4abn.jpg" alt="出栈.png"></p>
<h5 id="循环队列："><a href="#循环队列：" class="headerlink" title="循环队列："></a><strong>循环队列：</strong></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> head, tail, size, count;　<span class="comment">// count 记录有几个数，</span></span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;　<span class="comment">// 初始化一个队列</span></span><br><span class="line">    Queue *q = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    q-&gt;data =(<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    q-&gt;head = q-&gt;tail = q-&gt;count = <span class="number">0</span>;　<span class="comment">// 初始化为head = tail = count = 0;</span></span><br><span class="line">    q-&gt;size = n; <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Queue *q)</span> </span>&#123;　<span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">return</span> q-&gt;count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">(Queue *q)</span> </span>&#123;　<span class="comment">//返回队首部</span></span><br><span class="line">    <span class="keyword">return</span> q-&gt;data[q-&gt;head];　</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Queue *q, <span class="keyword">int</span> val)</span> </span>&#123;　<span class="comment">// 进队</span></span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;count == q-&gt;size) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    q-&gt;data[q-&gt;tail++] = val; </span><br><span class="line">    <span class="keyword">if</span>(q-&gt;tail == q-&gt;size)q-&gt;tail -= q-&gt;size;</span><br><span class="line">    q-&gt;count ++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Queue *q)</span> </span>&#123;　<span class="comment">// 删除</span></span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(empty(q))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q-&gt;head ++;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;head == q-&gt;size) q-&gt;head -= q-&gt;size;</span><br><span class="line">    q-&gt;count --;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Queue *q)</span> </span>&#123;　</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Queue(%d) = ["</span>, q-&gt;count);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = q-&gt;head, j = <span class="number">0</span>; j &lt; q-&gt;count; j++) &#123;</span><br><span class="line">        <span class="function">j &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">", "</span>)</span></span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, q-&gt;data[(i + j) % q-&gt;size]); <span class="comment">// 输出的时候从i = head 往后循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"]\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Queue *q)</span> </span>&#123; <span class="comment">//用到的</span></span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 20</span></span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Queue *q = init(max_op);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * max_op; i++) &#123;</span><br><span class="line">        op = rand() % <span class="number">4</span>;</span><br><span class="line">        val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"push %d to Queue = %d\n"</span>, val, push(q, val));</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"pop %d from Queue = "</span>, front(q));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pop(q));</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#####　循环队列的扩容：</p>
<p>（相当于顺序表的扩容）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> extr_size = q-&gt;size;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">while</span>(extr_size) &#123;</span><br><span class="line">        p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (q-&gt;size + extr_size));</span><br><span class="line">        <span class="keyword">if</span>(p)<span class="keyword">break</span>;</span><br><span class="line">        extr_size /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = q-&gt;head, j = <span class="number">0</span>; j &lt; q-&gt;count ; j++) &#123; <span class="comment">// 全部拷贝过来</span></span><br><span class="line">       p[j] = q-&gt;data[(i + j) % q-&gt;size];</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;size += extr_size;　<span class="comment">//再次初始化</span></span><br><span class="line">    q-&gt;head = <span class="number">0</span>;</span><br><span class="line">    q-&gt;tail = q-&gt;count;</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;data);　<span class="comment">// 释放</span></span><br><span class="line">    q-&gt;data = p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>realloc只是将原来数据直接放在那个上面，malloc不同</p>
<h5 id="栈："><a href="#栈：" class="headerlink" title="栈："></a><strong>栈：</strong></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> top, size;</span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Stack *s = (Stack *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    s-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    s-&gt;size = n;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Stack *s, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top + <span class="number">1</span> == s-&gt;size) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    s-&gt;data[++(s-&gt;top)] = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(empty(s))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    s-&gt;top -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Stack(%d) = ["</span>, s-&gt;top + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s-&gt;top; i++) &#123;</span><br><span class="line">        <span class="function">i &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">", "</span>)</span></span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, s-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"]\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(s-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 20</span></span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Stack *s = init(max_op);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">        op = rand() % <span class="number">4</span>;</span><br><span class="line">        val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"push %d to Stack = %d\n"</span>, val, push(s, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"pop %d from Stack = "</span>, top(s));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pop(s));</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(s);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clear(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="栈的扩容："><a href="#栈的扩容：" class="headerlink" title="栈的扩容："></a>栈的扩容：</h5><p>（相当于顺序表的扩容）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> extr_size = s-&gt;size;　<span class="comment">// 先记录一下s-&gt;size;</span></span><br><span class="line">    <span class="keyword">int</span> *p; </span><br><span class="line">    <span class="keyword">while</span>(extr_size) &#123; <span class="comment">// 直至扩容到结束</span></span><br><span class="line">        p = (<span class="keyword">int</span> *) <span class="built_in">realloc</span>(s-&gt;data, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (s-&gt;size + extr_size));</span><br><span class="line">        <span class="keyword">if</span>(p) <span class="keyword">break</span>;　<span class="comment">// 如果ｐ为０时，继续循环（因为realloc开辟失败时返回值为０）</span></span><br><span class="line">        extr_size /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 开辟失败时结束</span></span><br><span class="line">    s-&gt;size += extr_size; </span><br><span class="line">    s-&gt;data = p; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#####　系统栈求表达式结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_n  100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prior = <span class="number">0x3f3f3f3f</span> - <span class="number">1</span>, temp = <span class="number">0</span>, pos = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;<span class="comment">/*找到优先级最低的位置*/</span></span><br><span class="line">        <span class="keyword">int</span> cur_prior = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">switch</span>(str[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span>: temp += <span class="number">100</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span>: temp -= <span class="number">100</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>: cur_prior = temp + <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>: cur_prior = temp + <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'^'</span>: cur_prior = temp + <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur_prior &lt;= prior) &#123;</span><br><span class="line">            prior = cur_prior;</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] &lt; <span class="string">'0'</span> || str[i] &gt;<span class="string">'9'</span>)<span class="keyword">continue</span>;</span><br><span class="line">            num = num * <span class="number">10</span> + str[i] -<span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = calc(str, l , pos - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> b = calc(str, pos + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">switch</span>(str[pos]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>: <span class="keyword">return</span> a + b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>: <span class="keyword">return</span> a - b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>: <span class="keyword">return</span> a * b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>: <span class="keyword">return</span> a / b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'^'</span>: <span class="keyword">return</span> (<span class="keyword">int</span>)<span class="built_in">pow</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[max_n + <span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%[^\n]s"</span>, str) != EOF) &#123;</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, calc(str, <span class="number">0</span>, <span class="built_in">strlen</span>(str) - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gewzz7l8qsj30cq041dge.jpg" alt="2020-02-13 20-55-36屏幕截图.png"></p>
<h5 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h5><p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gf4yzes427j30hi0am442.jpg" alt="image.png"></p>
<p>主要维护一个单调性，来一个元素把所有违反单调性的元素移除掉</p>
<p>例如:</p>
<p>高中三个年级中选打比赛如上图</p>
<p><strong>滑动窗口</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 300000</span></span><br><span class="line"><span class="keyword">int</span> a[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> q[MAX_N + <span class="number">5</span>], head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(tail - head &amp;&amp; a[q[tail - <span class="number">1</span>]] &gt;= a[i]) tail --;</span><br><span class="line">        q[tail++] = i;</span><br><span class="line">        <span class="keyword">if</span>(q[head] &lt;= i - k) head ++;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; k) <span class="keyword">continue</span>;</span><br><span class="line">        i == k || <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[q[head]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    head = tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(tail - head &amp;&amp; a[q[tail - <span class="number">1</span>]] &lt;= a[i]) tail --;</span><br><span class="line">        q[tail ++] = i;</span><br><span class="line">        <span class="keyword">if</span>(q[head] &lt;= i - k) head++;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; k)<span class="keyword">continue</span>;</span><br><span class="line">        i == k || <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[q[head]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h5 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h5><p><strong>矩形面积</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s[MAX_N + <span class="number">5</span>], top = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> l[MAX_N + <span class="number">5</span>], r[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">0</span>] = a[n + <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    s[top = <span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[s[top]] &gt;= a[i]) -- top;</span><br><span class="line">        l[i] = s[top];</span><br><span class="line">        s[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    s[top = <span class="number">0</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[s[top]] &gt;= a[i]) -- top;</span><br><span class="line">        r[i] = s[top];</span><br><span class="line">        s[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans = max(ans, a[i] * (r[i] - l[i] - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-树与二叉树"><a href="#4-树与二叉树" class="headerlink" title="4.树与二叉树"></a>4.树与二叉树</h2><p>完全包含的数据结构：栈&lt;＝&gt;树</p>
<h5 id="树的结构定义"><a href="#树的结构定义" class="headerlink" title="树的结构定义"></a>树的结构定义</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span> <span class="comment">// 有很多指针指向struct Node *next[3]三个指向</span></span><br><span class="line">&#125;Node, *LinkedList;</span><br></pre></td></tr></table></figure>
<p>１．树的深度高度相同<br>２．节点的深度为根到结点，高度从此处往下看；<br>３．结点数量等于边数加１<br>４．树转化为二叉树：（左孩子右兄弟）＝【十字链表法】</p>
<h5 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h5><p>１．每个节点度最多为２<br>２．度为０的节点比度为２的节点多１个</p>
<blockquote>
<p>因为n1 + n0 + n2 = n1 + 0 + 2 * n2 + 1<br>所以n2 + 1 = n0</p>
</blockquote>
<p>３．N叉树，N个指针指向<br>４．因为无论一个怎样的N叉树都能转化为一个二叉树，所以二叉树更有意义；N叉树不确定，性二叉树确定性。<br>５．完全二叉树：（１）编号为ｉ左孩子编号为<em>2×i,</em>右孩子<em>2×i+1</em>，（２）可以用连续空间存储|数组|；<br>６．<font color = red>广义表</font>　－－　根（左，右）</p>
<p><img src="http://res.jisuanke.com/img/upload/20160406/2c589a6c7026a90dc27975acd63702ebaf1a35d0.png" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span><span class="comment">//二叉树结点的结构体 Node</span></span><br><span class="line">    <span class="keyword">int</span> data; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">// 左-右孩子</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure>

<p><strong>初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">init</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123; <span class="comment">//初始化函数 init</span></span><br><span class="line">    Node *node =(Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>清空释放</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        clear(node-&gt;lchild); <span class="comment">// 采用递归释放</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        clear(node-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>建立函数 build_demo</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">build_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node *node = init(<span class="number">1</span>); <span class="comment">// 通过init()进行建立关系</span></span><br><span class="line">    node-&gt;lchild = init( <span class="number">2</span>);</span><br><span class="line">    node-&gt;rchild = init(<span class="number">3</span>);</span><br><span class="line">    node-&gt;lchild-&gt;lchild = init(<span class="number">4</span>);</span><br><span class="line">    node-&gt;lchild-&gt;rchild = init(<span class="number">5</span>);</span><br><span class="line">    node-&gt;rchild-&gt;rchild = init(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h5><h6 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h6><p>从根节点开始，先访问当前节点，如果左边子树不为空，则继续访问左子树，之后若右子树不为空再访问右子树，进行遍历；(根-&gt;左-&gt;右)</p>
<p><img src="https://res.jisuanke.com/img/upload/20161108/59c39c81ee495f030b8bae1fd80b6f6b7f715f19.gif" alt="img"></p>
<p>如图Ｌ访问结束后在访问Ｙ</p>
<p><img src="https://res.jisuanke.com/img/upload/20161108/effe9371c61337852a033ef5b89da26ab35ec356.gif" alt="img"></p>
<p>按照这样接着遍历ｗ的右子树,遍历完之后回溯到Ｍ，最后把M的右子树遍历完。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, node-&gt;data);<span class="comment">//把当前节点的数据域输出</span></span><br><span class="line">    <span class="keyword">if</span>(node-&gt;lchild!= <span class="literal">NULL</span>) &#123; <span class="comment">//如果左子树不为空，递归调用其函数preorder</span></span><br><span class="line">        preorder(node-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;rchild != <span class="literal">NULL</span>) &#123; <span class="comment">//同理访问右子数</span></span><br><span class="line">        preorder(node-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h6><p>中序遍历是从当前的左子树开始遍历，再访问当前节点最后访问右子树（左-&gt;根-&gt;右）</p>
<p><img src="https://res.jisuanke.com/img/upload/20161108/c2da0f438ca7a8a5b5968ee75727a4d17b6fd459.gif" alt="img"></p>
<p>向左访问直到Ｗ，然后继续访问中Ｇ然后访问Ｌ</p>
<p><img src="https://res.jisuanke.com/img/upload/20161108/60d71ed22aeed22c3f4b4e45f15dfa8956cde880.gif" alt="img"></p>
<p>回溯待Ｖ输出，继续访问其右子树；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;lchild != <span class="literal">NULL</span>) &#123; <span class="comment">//先访问左子树不为空，递归调用</span></span><br><span class="line">        inorder(node-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, node-&gt;data);　<span class="comment">// 访问完左子树访问当前节点</span></span><br><span class="line">    <span class="keyword">if</span>(node-&gt;rchild!=<span class="literal">NULL</span>) &#123;　<span class="comment">// 最后递归访问右子树</span></span><br><span class="line">        inorder(node-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h6><p>后序遍历是从当前的左子树开始遍历，再访问右节点最后访问当前节点（左-&gt;右-&gt;根）</p>
<img src="https://res.jisuanke.com/img/upload/20161108/231b93e962bec9efcc4fb76e939d7478388bf774.gif" alt="img" style="zoom: 67%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;lchild != <span class="literal">NULL</span>) &#123; <span class="comment">//先访问左子树不为空，递归调用</span></span><br><span class="line">        postorder(node-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;rchild != <span class="literal">NULL</span>) &#123; <span class="comment">//再访问右子树不为空。递归</span></span><br><span class="line">        postorder(node-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, node-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="已知先序和中序求后序"><a href="#已知先序和中序求后序" class="headerlink" title="已知先序和中序求后序"></a>已知先序和中序求后序</h6><p>参数：<code>pre_str[],  in_str[],  len</code>分别为先序、中序、遍历中序遍历的个数。</p>
<p>思路：我们先获取根节点在先序中的编号，在中序遍历中我们找到根节点的所在位置，那么位置前面的结点就是左子树上的结点，位置后面的就是根节点右子树上的结点。然后递归建立二叉树；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立二叉树的函数 build</span></span><br><span class="line"><span class="function">Node *<span class="title">build</span><span class="params">(<span class="keyword">char</span> pre_str[], <span class="keyword">char</span> in_str[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    Node *p = init(pre_str[<span class="number">0</span>] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="built_in">strchr</span>(in_str, pre_str[<span class="number">0</span>]) - in_str;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        p-&gt;lchild = build(pre_str + <span class="number">1</span>, in_str, pos);　<span class="comment">// 1 ~ pos</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len - pos - <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        p-&gt;rchild = build(pre_str + pos + <span class="number">1</span>, in_str + pos + <span class="number">1</span>, len - pos - <span class="number">1</span>); <span class="comment">// pos + 1 ~ len - pos - 1</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gewzzmjkanj30cw04xjso.jpg" alt="2020-02-15 15-35-04屏幕截图.png"></p>
<h5 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h5><p>主要是为了解决８ＭＢ系统栈的爆。<br>１．左空指前驱，右空指向后继（中序遍历前提）；<br>２．ｌｔａｇ前驱，ｒｔａｇ后继（区分左右孩子）<br>３．优点：<br>(1)利用线索二叉树进行中序遍历时，不必采用堆栈处理，速度较一般二叉树的遍历速度快，且节约存储空间。<br>(2)任意一个结点都能直接找到它的前驱和后继结点。<br>４．<font color = red>一个结点的前驱是左子树最右边的结点，后继是右子树的最左结点。</font></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex003sq2fj30h00avdgy.jpg" alt="build_thread.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NORMAL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node*<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = val;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;ltag = NORMAL;</span><br><span class="line">    p-&gt;rtag = NORMAL;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> getNewNode(val);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data == val)<span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span>(val &lt; root-&gt;data) root-&gt;lchild = insert(root-&gt;lchild, val);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insert(root-&gt;rchild, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_thread</span><span class="params">(Node *root)</span> </span>&#123; <span class="comment">// 1 -&gt; 2-&gt; 4,</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">static</span> Node *pre = <span class="literal">NULL</span>; </span><br><span class="line">    build_thread(root-&gt;lchild); <span class="comment">// 先建立左子树</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lchild == <span class="literal">NULL</span>) &#123;　<span class="comment">// 走到最左边为空时</span></span><br><span class="line">        root-&gt;lchild = pre;　<span class="comment">// 4 -&gt;NULL</span></span><br><span class="line">        root-&gt;ltag = THREAD;  <span class="comment">// 标记已经线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;　<span class="comment">// 4回溯为２，此处构造为４-&gt;root (2)</span></span><br><span class="line">        pre-&gt;rchild = root;</span><br><span class="line">        pre-&gt;rtag = THREAD;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root; <span class="comment">// 此时pre 为4处的ｒｏｏｔ</span></span><br><span class="line">    build_thread(root-&gt;rchild);　<span class="comment">// 继续构造右边的子树</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">most_left</span><span class="params">(Node *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;p-&gt;ltag == NORMAL &amp;&amp; p-&gt;lchild != <span class="literal">NULL</span>) p=p-&gt;lchild;　<span class="comment">// p一直往左走</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *p = most_left(root);　<span class="comment">// 先走到最走边结点４</span></span><br><span class="line">    <span class="keyword">while</span>(p) &#123;　<span class="comment">// p不为空不挑出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);　</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rtag == THREAD) &#123; <span class="comment">// 如果存在右边线索往右走</span></span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;　　<span class="comment">//不存在的话往右子树的最左子树</span></span><br><span class="line">            p = most_left(p-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;ltag == NORMAL)in_order(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;data);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;rtag == NORMAL) in_order(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;ltag == NORMAL) clear(root-&gt;lchild);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;rtag == NORMAL)clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 20</span></span><br><span class="line">    Node *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        root = insert(root, val);</span><br><span class="line">    &#125;</span><br><span class="line">    build_thread(root);</span><br><span class="line">    output(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    in_order(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    clear(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二叉树转广义表"><a href="#二叉树转广义表" class="headerlink" title="二叉树转广义表"></a>二叉树转广义表</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    Node *root;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;Tree;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = val;</span><br><span class="line">    p-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree *<span class="title">getNewTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Tree *tree = (Tree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tree));</span><br><span class="line">    tree-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insertNode</span><span class="params">(Node *root, <span class="keyword">int</span> val, <span class="keyword">int</span> *ret)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123; <span class="comment">/*插入成功*/</span></span><br><span class="line">        *ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getNewNode(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data == val) <span class="keyword">return</span> root; <span class="comment">// 插入失败</span></span><br><span class="line">    <span class="keyword">if</span>(val &lt; root-&gt;data) root-&gt;lchild = insertNode(root-&gt;lchild,val, ret);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insertNode(root-&gt;rchild, val, ret);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Tree *tree, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    tree-&gt;root = insertNode(tree-&gt;root, val, &amp;flag);</span><br><span class="line">    tree-&gt;n += flag; <span class="comment">// 不知道插入成功还是失败</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outputNode</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, root-&gt;data);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"("</span>);</span><br><span class="line">    outputNode(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">","</span>);</span><br><span class="line">    outputNode(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Tree(%d) = "</span>, tree-&gt;n);</span><br><span class="line">    outputNode(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*前序遍历*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_orderNode</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;data);</span><br><span class="line">    pre_orderNode(root-&gt;lchild);</span><br><span class="line">    pre_orderNode(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pre_order :"</span>);</span><br><span class="line">    pre_orderNode(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中序遍历*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_orderNode</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    in_orderNode(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;data);</span><br><span class="line">    in_orderNode(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"in_order :"</span>);</span><br><span class="line">    in_orderNode(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*后序遍历*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_orderNode</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    post_orderNode(root-&gt;lchild);</span><br><span class="line">    post_orderNode(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;data);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"post_order :"</span>);</span><br><span class="line">    post_orderNode(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_Node</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    clear_Node(node-&gt;lchild);</span><br><span class="line">    clear_Node(node-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_Tree</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    clear_Node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 10</span></span><br><span class="line">    Tree *tree = getNewTree();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        insert(tree, val);</span><br><span class="line">        output(tree);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    preorder(tree);</span><br><span class="line">    inorder(tree);</span><br><span class="line">    postorder(tree);</span><br><span class="line">    clear_Tree(tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="广义表转二叉树"><a href="#广义表转二叉树" class="headerlink" title="广义表转二叉树"></a>广义表转二叉树</h5><p>１.字符　２．左括号　３．逗号　４．右括号</p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex01sc0njj31hc0u0dqo.jpg" alt="2020-02-15 20-29-43屏幕截图.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    Node *root;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;Tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    Node **data; <span class="comment">/*Stack此处应该是Node *类型*/</span></span><br><span class="line">    <span class="keyword">int</span> top, size;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">char</span> val)</span> </span>&#123; <span class="comment">/* 获取一个新的结点*/</span></span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = val;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree *<span class="title">getNewTree</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/* 获取一个新的树*/</span></span><br><span class="line">    Tree *tree = (Tree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tree));</span><br><span class="line">    tree-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack *<span class="title">init_stack</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">//初始化一个栈</span></span><br><span class="line">    Stack *s = (Stack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    s-&gt;data = (Node **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node *) * n); <span class="comment">// 开辟数据的长度为ｎ的大小个，结点类型的</span></span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;<span class="comment">// 初始化栈顶都为-１</span></span><br><span class="line">    s-&gt;size = n;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Stack *s)</span> </span>&#123; <span class="comment">//判断一个栈是否为空</span></span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">top</span><span class="params">(Stack *s)</span> </span>&#123;<span class="comment">// 返回栈顶元素，返回类型为Node *类型，为结点类型</span></span><br><span class="line">    <span class="keyword">return</span> s-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Stack *s, Node *val)</span> </span>&#123; <span class="comment">// 结点入栈操作,此处为Node *val</span></span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top == s-&gt;size - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    s-&gt;data[++(s-&gt;top)] = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Stack *s)</span> </span>&#123; <span class="comment">//删除栈顶操作</span></span><br><span class="line">    <span class="keyword">if</span>(empty(s)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    s-&gt;top -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_stack</span><span class="params">(Stack *s)</span></span>; </span><br><span class="line"><span class="function">Node *<span class="title">build</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> *node_num)</span> </span>&#123; <span class="comment">//建立二叉树，由广义表转二叉树</span></span><br><span class="line">    Node *temp = <span class="literal">NULL</span>, *p = <span class="literal">NULL</span>; <span class="comment">//定义两个结点</span></span><br><span class="line">    Stack *s = init_stack(<span class="built_in">strlen</span>(str));<span class="comment">// 初始化一个栈大小为字符串长度</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">//标记，如果遇到“，”则为１，告诉下面是左还是右子树</span></span><br><span class="line">    <span class="keyword">while</span>(str[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(str[<span class="number">0</span>]) &#123; <span class="comment">//如果不是\n继续往后遍历</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span> :   </span><br><span class="line">                   push(s, temp);<span class="comment">//如果遇到（将入栈</span></span><br><span class="line">                   flag = <span class="number">0</span>;</span><br><span class="line">                   temp = <span class="literal">NULL</span>;<span class="comment">//将temp置空</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span> :</span><br><span class="line">                   p = top(s); <span class="comment">//如果遇到）时出栈</span></span><br><span class="line">                   pop(s);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">','</span> :</span><br><span class="line">                   flag = <span class="number">1</span>; <span class="comment">//遇到“，”标记，将temp＝ＮＵＬＬ；</span></span><br><span class="line">                   temp = <span class="literal">NULL</span>; <span class="comment">//告诉下面右子树为空</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">' '</span> :</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>  : <span class="comment">// 如果是字母</span></span><br><span class="line">                   temp = getNewNode(str[<span class="number">0</span>]);<span class="comment">//获取一个节点</span></span><br><span class="line">                   <span class="keyword">if</span>(!empty(s)&amp;&amp; flag == <span class="number">0</span>)&#123; <span class="comment">//如果栈不为空，并且为左子树</span></span><br><span class="line">                   top(s) -&gt;lchild = temp; </span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!empty(s)&amp;&amp;flag == <span class="number">1</span>) &#123; <span class="comment">//如果栈不为空，并且为右子树，</span></span><br><span class="line">                   top(s) -&gt;rchild = temp;</span><br><span class="line">                   &#125;</span><br><span class="line">                   ++(*node_num);<span class="comment">//创建一个成功后记录个数</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++str; <span class="comment">// str往后移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    clear_stack(s); <span class="comment">//清空栈</span></span><br><span class="line">    <span class="keyword">if</span>(temp &amp;&amp; !p) p = temp;<span class="comment">// temp 不为空，p为空,将p = temp;</span></span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">//返回p，p为顶</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中序遍历*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_orderNode</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    in_orderNode(node-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, node-&gt;data);</span><br><span class="line">    in_orderNode(node-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"in_order : "</span>);</span><br><span class="line">    in_orderNode(tree-&gt;root);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*前序遍历*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_orderNode</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, node-&gt;data);</span><br><span class="line">    pre_orderNode(node-&gt;lchild);</span><br><span class="line">    pre_orderNode(node-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pre_order : "</span>);</span><br><span class="line">    pre_orderNode(tree-&gt;root);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*后序遍历*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_orderNode</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    post_orderNode(node-&gt;lchild);</span><br><span class="line">    post_orderNode(node-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>,node-&gt;data);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"post_order : "</span>);</span><br><span class="line">    post_orderNode(tree-&gt;root);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear_node(node-&gt;lchild);</span><br><span class="line">    clear_node(node-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_tree</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    clear_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_stack</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(s-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%[^\n]s"</span>, str);</span><br><span class="line">    <span class="keyword">int</span> node_num = <span class="number">0</span>;</span><br><span class="line">    Tree *tree = getNewTree();</span><br><span class="line">    tree-&gt;root = build(str, &amp;node_num);</span><br><span class="line">    tree-&gt;n = node_num;</span><br><span class="line">    pre_order(tree), <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    in_order(tree), <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    post_order(tree), <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    clear_tree(tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="５-堆与优先队列"><a href="#５-堆与优先队列" class="headerlink" title="５.堆与优先队列"></a>５.堆与优先队列</h2><p><strong>完全二叉树:</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex02kazyqj30mb076wfr.jpg" alt="2020-02-18 15-40-26屏幕截图.png"></p>
<p>一个根结点root它左孩子root * 2 + 1, 右孩子root * 2 + 2<br>那么一个孩子求父节点为(lchild  - 1) / 2, (rchild - 1) / 2</p>
<h5 id="堆："><a href="#堆：" class="headerlink" title="堆："></a><strong>堆：</strong></h5><p>大顶堆：当前任意一个根节点大于其两个孩子（最大值放在根）<br>小顶堆：当前任意一个根节点小于其两个孩子（最小值放在根）</p>
<p><em>结构操作：</em><br>插入：<br>　　插入在尾部–调整为了保持堆序性，接下来我们要通过比较元素的父结点权值，做从小到大的堆调整。如果元素比父结点权值大，则将元素与其父结点进行交换。如果还比此时的父结点权值大，则继续调整，否则结束调整操作。<br><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex02xx7yej30m708kgnk.jpg" alt="2020-02-18 15-52-15屏幕截图.png">调整的时候不断向上调整直至满足大顶堆。</p>
<p>输出堆顶：<br>　　先拿出堆顶h-&gt;data[0]，然后让最后一个值覆盖，调整的时候不断向下调整直至满足大顶堆。</p>
<h5 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a><strong>优先队列</strong></h5><p>优先队列内部一般是用堆来实现的。我们知道堆的插入、删除操作的时间复杂度都是 O(log<em>N</em>)，自然优先队列的插入、删除操作的时间复杂度也都O(log<em>N</em>)。堆中的堆顶元素就是优先队列的队首元素。<br><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex036mf58j30hr09imyo.jpg" alt="2020-02-18 16-14-30屏幕截图.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123;\</span></span><br><span class="line">    __typeof(a) __temp = a;\</span><br><span class="line">    a = b, b = __temp;\</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">priority_queue</span>&#123;</span> <span class="comment">//结构定义优先队列</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> cnt, size; </span><br><span class="line">&#125;priority_queue;</span><br><span class="line"></span><br><span class="line"><span class="function">priority_queue *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;　<span class="comment">//获取一个队列</span></span><br><span class="line">    priority_queue *q = (priority_queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(priority_queue));</span><br><span class="line">    q-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * ( n + <span class="number">1</span> ));</span><br><span class="line">    q-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    q-&gt;size = n;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(priority_queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;cnt == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(priority_queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;data[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(priority_queue *q, <span class="keyword">int</span> val)</span> </span>&#123;　<span class="comment">// 插入</span></span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;cnt == q-&gt;size)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q-&gt;cnt += <span class="number">1</span>;<span class="comment">//先往后移动一下</span></span><br><span class="line">    q-&gt;data[q-&gt;cnt] = val;<span class="comment">// 将值插入</span></span><br><span class="line">    <span class="keyword">int</span> ind = q-&gt;cnt; <span class="comment">//初始ｉｎｄ= 末尾</span></span><br><span class="line">    <span class="keyword">while</span>(ind &gt;&gt; <span class="number">1</span> &amp;&amp; q-&gt;data[ind] &gt; q-&gt;data[ind &gt;&gt; <span class="number">1</span>]) &#123;<span class="comment">//如果此时根节点小于子节点</span></span><br><span class="line">        swap(q-&gt;data[ind], q-&gt;data[ind &gt;&gt; <span class="number">1</span>]);<span class="comment">//交换</span></span><br><span class="line">        ind &gt;&gt;= <span class="number">1</span>;<span class="comment">//继续／２，相当于根节点继续往上走</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(priority_queue *q)</span> </span>&#123;　</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(empty(q)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q-&gt;data[<span class="number">1</span>] = q-&gt;data[q-&gt;cnt--];<span class="comment">//先将最后一位覆盖第一位，总数减一</span></span><br><span class="line">    <span class="keyword">int</span> ind = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>((ind &lt;&lt; <span class="number">1</span>) &lt;= q-&gt;cnt ) &#123;<span class="comment">//如果子节点不超过最后一位</span></span><br><span class="line">        <span class="keyword">int</span> temp = ind, l = ind &lt;&lt; <span class="number">1</span>, r = ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;data[l] &gt; q-&gt;data[temp]) temp = l; <span class="comment">//如果左孩子大于最大结点将它付给最大节点</span></span><br><span class="line">        <span class="keyword">if</span>(r &lt;= q-&gt;cnt &amp;&amp; q-&gt;data[r] &gt; q-&gt;data[temp])temp = r;<span class="comment">//将右边孩子与最大节点相比较，找出最大节点</span></span><br><span class="line">        <span class="keyword">if</span>(temp == ind)<span class="keyword">break</span>; <span class="comment">//如果没有找到</span></span><br><span class="line">        swap(q-&gt;data[ind], q-&gt;data[temp]);</span><br><span class="line">        ind = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(priority_queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 20</span></span><br><span class="line">    priority_queue *q = init(max_op);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        push(q, val);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"insert %d to queue\n"</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, top(q));</span><br><span class="line">        pop(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    clear(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="堆排序："><a href="#堆排序：" class="headerlink" title="堆排序："></a>堆排序：</h5><p>１．将对顶元素与堆尾部交换<br>２．将此操作看做对顶元素弹出操作<br>３．按照头部弹出后策略调整</p>
<p>首先我们得到一个大根堆，然后从堆的最后一个元素开始，依次往前遍历，每次首先将堆顶元素和当前元素进行交换，交换后再对新的堆顶做一个自上而下的堆调整。堆排序和选择排序有些类似，每次选一个最大值和当前元素交换，只不过这里是利用堆来维护，调整效率比选择排序高了很多，时间复杂度可以达到 O(log n)，要交换<code>n</code>次，调整<code>n</code>次，所以堆排序的时间复杂度为 O(<em>n</em>log<em>n</em>)。</p>
<p>自上而下自上而下:</p>
<p>子和父亲比只需要比一次就可以调整 ,不需要讲同层元素与父节点比较 , 由于是自底向上建立堆，因此在调整上层元素的时候，并不需要同下层所有元素做比较，只需要同其中之一分支作比较, 自上而下一层比两个，父节点和左子节点比一次，父节点和右子节点比一次，自下而上，只需要当前节点和父亲比就可以了 .</p>
<p>堆排序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123;\</span></span><br><span class="line">    __typeof(a) __temp = a;\</span><br><span class="line">    a = b; b = __temp;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downUpdate</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n, <span class="keyword">int</span> ind)</span> </span>&#123; <span class="comment">//自顶向下调整</span></span><br><span class="line">    <span class="keyword">while</span>((ind &lt;&lt; <span class="number">1</span>) &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = ind, l = ind &lt;&lt; <span class="number">1</span>, r = ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[l] &gt; arr[temp]) temp = l;</span><br><span class="line">        <span class="keyword">if</span>(r &lt;= n &amp;&amp; arr[r] &gt; arr[temp]) temp = r;</span><br><span class="line">        <span class="keyword">if</span>(temp == ind) <span class="keyword">break</span>;</span><br><span class="line">        swap(arr[temp], arr[ind]);</span><br><span class="line">        ind = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    arr -= <span class="number">1</span>;　<span class="comment">// 因为传过来的arr值是从0开始的，我们想从１开始访问，那么必须地址往后移动一位；也就是原１的地址现在存原０值；</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n &gt;&gt; <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;　<span class="comment">// 从ｎ/2开始往前调整初建立堆</span></span><br><span class="line">        downUpdate(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;　<span class="comment">// 堆排序；</span></span><br><span class="line">        swap(arr[i], arr[<span class="number">1</span>]);</span><br><span class="line">        downUpdate(arr, i - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"arr(%d) = ["</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"]\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 21</span></span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * max_op);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        arr[i] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    output(arr, max_op);</span><br><span class="line">    heap_sort(arr, max_op);</span><br><span class="line">    output(arr, max_op);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex03hibblj30cu02d0t8.jpg" alt="2020-02-18 16-15-39屏幕截图.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex03t286hj30qk0hw0vz.jpg" alt="2020-02-18 18-37-49屏幕截图.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex042bjkqj30qm0hrta6.jpg" alt="2020-02-18 18-46-52屏幕截图.png"></p>
<h2 id="６-排序算法"><a href="#６-排序算法" class="headerlink" title="６.排序算法"></a>６.排序算法</h2><p><strong>外部排序</strong>指的是大文件的排序，即待排序的记录存储在<a href="https://baike.baidu.com/item/外存储器/1226993" target="_blank" rel="noopener">外存储器</a>上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。<br>例如归并排序<br><strong>内部排序</strong>是指待排序列完全存放在内存中所进行的排序过程，适合不太大的元素序列。<br>排序是计算机程序设计中的一种重要操作，其功能是对一个<a href="https://baike.baidu.com/item/数据元素" target="_blank" rel="noopener">数据元素</a>集合或序列重新排列成一个按数据元素某个相知有序的序列。排序分为两类：内排序和外排序。<br>其中<a href="https://baike.baidu.com/item/快速排序" target="_blank" rel="noopener">快速排序</a>是排序方法中被认为是最好的方法。</p>
<h5 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a>稳定排序</h5><p><em>稳定的意思是两个相同的值在排序后两者先后顺序不变即为稳定！</em><br>稳定排序包括：<strong>插入排序</strong>，<strong>冒泡排序</strong>， <strong>归并排序</strong></p>
<h6 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h6><p>1.将数组分成已排序区和待排序区间<br>2.将已排序区后面的一个元素，向前插入到待排序区中<br>3.直到待排序区没有元素为止<br><img src="http://res.jisuanke.com/img/upload/20160304/3eca19c223fd1d9bffaff6a240fbbac00c400b84.gif" alt="插入排序"><br>插入排序每次插入的时间复杂度为 O(n)，一共执行n−1 次，因此总体时间复杂度为 O(n^2)。在插入时查找插入位置的过程可以使用折半查找算法将查找位置的复杂度优化到 O(logn)，但因为还需要 O(n) 的时间复杂度来在顺序表上执行移动操作，所以总体时间复杂度依然是 O(n＾2)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; num[j] &lt; num[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            swap(num[j], num[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>######　冒泡排序<br>1.将数组分为已排序区和待排序区<br>2.从头到尾扫描待排序区，若前面元素比后面元素大，则交换<br>3.每一轮都会将待排序区中最大的放在已排序区的开头<br>4.直到待排序区没有元素为止<br><img src="http://res.jisuanke.com/img/upload/20160304/044b7de55573d738ad71c7820f628a76df26d6c9.gif" alt="冒泡排序"><br>冒泡排序算法的基本思想为：假如待排序线性表的长度为<code>n</code>，从前往后两两比较相邻元素的关键字，若 <code>ai−1&gt;ai</code>，则交换它们，直到线性表比较完成。每趟交换以后最后一个元素一定是最大的，不再参与下一趟交换。也就是对于第i趟交换，只需要比较到 <code>an−i</code> 即可。直到一趟比较内没有进行交换，算法结束。时间复杂度和插入排序一样，也为<code>O(n^2)</code>。<br><font color = blue>优化</font>：标记交换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> times;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span> &amp;&amp; times; i++) &#123;</span><br><span class="line">        times = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[j] &gt; num[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(num[j], num[j + <span class="number">1</span>]);</span><br><span class="line">                times++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h6><p><img src="http://res.jisuanke.com/img/upload/20160303/012e9ba7cd5dcbc4f0ccb7caa185e4f9769d29ed.gif" alt="归并排序"><br>归并排序一共需要进行 <code>O(logn)</code>层归并操作，每层归并操作的总时间复杂度为 <code>O(n)</code>，因此总体的时间复杂度为<font color = red><code>O(nlogn)</code></font>。和其他排序有所不同，为了实现归并操作，每次合并都需要开辟额外的空间来临时保存合并后的排序结果，总共需要开辟 <code>n</code>个元素的空间，所以归并排序的空间复杂度为<code>O(n)</code>(<em>分治思想</em>)<img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex04eckwtj30iw06m40n.jpg" alt="2020-02-20 15-40-21屏幕截图.png"><br><font color = red>类似二叉树的后序遍历</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r - l &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(r - l == <span class="number">1</span> &amp;&amp; num[l] &gt; num[r]) &#123;</span><br><span class="line">            swap(num[l], num[r]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge_sort(num, l, mid);</span><br><span class="line">    merge_sort(num, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">int</span> *temp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(r - l + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> p1 = l, p2 = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid||p2 &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p2 &gt; r || (p1 &lt;= mid &amp;&amp; num[p1] &lt;= num[p2])) &#123;</span><br><span class="line">            temp[k++] = num[p1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = num[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(num + l, temp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (r - l + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="不稳定排序"><a href="#不稳定排序" class="headerlink" title="不稳定排序"></a>不稳定排序</h5><p>不稳定排序有<strong>选择排序</strong>　<strong>快速排序</strong></p>
<h6 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h6><p>1.将数组分为已排序区和待排序区<br>2.每一轮从待排序区选择一个最小的元素放在已排序区的尾部<br>3.直到待排序区没有元素<br><img src="http://res.jisuanke.com/img/upload/20160304/9c965158bc6178ef603ade226071fabb9a624a67.gif" alt="选择排序"><br>因为每趟可以让待排序区域的元素数量减少一个，所以总共需要 <code>n−1</code> 趟操作就可以将整个线性表排序完成。很显然，选择排序的时间复杂度也是 <code>O(n^2)</code>。<br>在每次查找关键字最小的元素时，可以使用堆对效率进行优化，使用堆来优化的选择排序就是堆排序。由于一共要查找 <code>n</code> 次最小值，每次查找的时间为 <code>O(logn)</code>，所以堆排序的时间复杂度为 <code>O(nlogn)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[ind] &gt; num[j]) ind = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(num[ind], num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>######　快速排序</p>
<p><img src="http://res.jisuanke.com/img/upload/20160304/7a3c9a32f9e675cab345ef47dcd9c0db087105f8.gif" alt="快速排序"></p>
<p>快速排序是目前应用最广泛的排序算法之一。它的基本思想是，每次从待排序区间选取一个元素（我们在后面的课程中都是选取第一个）作为基准记录，所有比基准记录小的元素都在基准记录的左边，而所有比基准记录大的元素都在基准记录的右边。之后分别对基准记录的左边和右边两个区间进行快速排序，直至将整个线性表排序完成。<br>快速排序的时间复杂度不是稳定的，可以证明快速排序的平均时间复杂度为 <code>O(nlogn)</code>，最坏情况为<code>O(n^2)</code>，可以通过随机选择基准记录来尽可能避免最坏情况的出现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; l) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> x = l, y = r, z = num[l];</span><br><span class="line">    <span class="keyword">while</span>(x &lt; y) &#123;</span><br><span class="line">        <span class="keyword">while</span>(x &lt; y &amp;&amp; num[y] &gt;= z) y--;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; y)num[x++] = num[y];</span><br><span class="line">        <span class="keyword">while</span>(x &lt; y &amp;&amp; num[x] &lt;= z) x++;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; y)num[y--] = num[x];</span><br><span class="line">    &#125;</span><br><span class="line">    num[x] = z;</span><br><span class="line">    quick_sort(num, l, x - <span class="number">1</span>);</span><br><span class="line">    quick_sort(num, x + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, r = r + <span class="number">1</span>, x = num[(l + r) &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(num[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j --; <span class="keyword">while</span>(num[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) &#123;</span><br><span class="line">            swap(num[i], num[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(q, l, j), quick(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>##　７.查找</p>
<h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex04qp9koj30j409a40d.jpg" alt="2020-02-20 19-53-09屏幕截图.png"><br>我们把有序表折半查找的过程用一棵 <strong>二叉判定树（binary decision tree, BDT）</strong><img src="https://res.jisuanke.com/img/upload/20161216/9ca8b51f46323ed9e79761334908c1e462340cbc.png" alt="img" style="zoom:50%;" />表示<br>通过这样一棵树，我们可以很容易计算出折半查找算法查找成功的平均查找长度<br><em>A<strong>S</strong>L</em>=1×1/6+2×2/6+3×3/6=7/3<br>而如果用顺序查找算法，平均查找长度为：3<br>可以看出，折半查找是比顺序查找更高效的查找算法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 3 5 7 9 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search1</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = n - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(head &lt;= tail) &#123;</span><br><span class="line">        mid = (head + tail) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num[mid] == x) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(num[mid] &lt; x) head = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> tail = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>二分变形:</strong></p>
<blockquote>
<p>arr[mid] == 1; min = mid;<br>arr[mid] != 1; max = mid - 1;</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex053axckj30hs0aq76m.jpg" alt="2020-02-20 20-05-34屏幕截图.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1111111000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search2</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">-1</span>, tail = n - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(head &lt; tail) &#123;</span><br><span class="line">        mid = (head + tail + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; <span class="comment">//避免出现死循环</span></span><br><span class="line">        <span class="keyword">if</span>(num[mid] == <span class="number">1</span>) head = mid;</span><br><span class="line">        <span class="keyword">else</span> tail = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex05cgk0oj30pb0e7wk5.jpg" alt="2020-02-20 20-16-00屏幕截图.png"></p>
<blockquote>
<p>arr[mid] == 1, max = mid;<br>arr[mid] != 1, min = mid + 1;</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//000000111111</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search3</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = n, mid;</span><br><span class="line">    <span class="keyword">while</span>(head &lt; tail) &#123;</span><br><span class="line">        mid = (head + tail) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num[mid] == <span class="number">1</span>)tail = mid;</span><br><span class="line">        <span class="keyword">else</span> head = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head == n ? <span class="number">-1</span> : head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>#####　三分查找<br><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex05prap3j30l70amdht.jpg" alt="2020-02-20 20-08-57屏幕截图.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex05yr1y8j30as04t0u6.jpg" alt="2020-02-20 23-52-52屏幕截图.png"></p>
<h2 id="８-哈希表"><a href="#８-哈希表" class="headerlink" title="８.哈希表"></a>８.哈希表</h2><p>思想：将任意类型的元素映射成整形直接索引<br><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex06ezzdoj30is072di9.jpg" alt="2020-02-22 14-33-34屏幕截图.png"><br>通过一个哈希函数，进行插入（有可能冲突），如果查找的时候，用哈希函数进行索引<br>冲突处理：<img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex06qcek1j30if06zdi7.jpg" alt="2020-02-22 14-37-02屏幕截图.png"><br>４大类冲突处理：<strong>开放地址法，拉链法，再哈希法，建立公共溢出区</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="comment">// 结构定义一个字符串类型的链表结点</span></span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> &#123;</span>　<span class="comment">// 结构定义哈希表</span></span><br><span class="line">    Node **data; <span class="comment">//Node *类型的哈希表</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;HashTable;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">init_node</span><span class="params">(<span class="keyword">char</span> *str, Node *head)</span> </span>&#123;　<span class="comment">//初始化一个字符串型的结点</span></span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;str = strdup(str);<span class="comment">//将字符串赋值给p-&gt;str</span></span><br><span class="line">    p-&gt;next = head;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HashTable *<span class="title">init_hashtable</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    HashTable *h = (HashTable *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashTable));</span><br><span class="line">    h-&gt;size = n &lt;&lt; <span class="number">1</span>; <span class="comment">//通常哈希表初始化为二倍的大小</span></span><br><span class="line">    h-&gt;data = (Node **)<span class="built_in">calloc</span>(h-&gt;size, <span class="keyword">sizeof</span>(Node *));<span class="comment">//清地址</span></span><br><span class="line"><span class="comment">/*calloc // 并初始化所有分配存储中的字节为零。</span></span><br><span class="line"><span class="comment">void* calloc( size_t num, size_t size ); </span></span><br><span class="line"><span class="comment">为 num 个对象的数组分配内存，并初始化所有分配存储中的字节为零。</span></span><br><span class="line"><span class="comment">若分配成功，会返回指向分配内存块最低位（首位）字节的指针，它为任何类型适当地对齐。</span></span><br><span class="line"><span class="comment">若 size 为零，则行为是实现定义的（可返回空指针，或返回不可用于访问存储的非空指针）。</span></span><br><span class="line"><span class="comment">https://zh.cppreference.com/w/c/memory/calloc</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BKDRHash</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;<span class="comment">//将一个字符串的映射成整形</span></span><br><span class="line">    <span class="keyword">int</span> seed = <span class="number">31</span>, hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) hash = hash * seed + str[i];</span><br><span class="line">    <span class="keyword">return</span> hash &amp; <span class="number">0x7fffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BKDRhash是通过前人研究出来，此时冲突是最少的，技巧</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(HashTable *h, <span class="keyword">char</span> *str)</span> </span>&#123; <span class="comment">//插入哈希表中</span></span><br><span class="line">    <span class="keyword">int</span> hash = BKDRHash(str);<span class="comment">//获取字符串对应的整型数值</span></span><br><span class="line">    <span class="keyword">int</span> ind = hash % h-&gt;size; <span class="comment">//通过哈希函数映射一个索引</span></span><br><span class="line">    h-&gt;data[ind] = init_node(str, h-&gt;data[ind]); <span class="comment">//将字符串插入对应的哈希表中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(HashTable *h, <span class="keyword">char</span> *str)</span> </span>&#123;<span class="comment">//查找是否存在</span></span><br><span class="line">    <span class="keyword">int</span> hash = BKDRHash(str);</span><br><span class="line">    <span class="keyword">int</span> ind = hash % h-&gt;size;</span><br><span class="line">    Node *p = h-&gt;data[ind]; <span class="comment">//创建一个Node *类型的指针指向索引到的地方</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; <span class="built_in">strcmp</span>(p-&gt;str, str))p = p-&gt;next;<span class="comment">//比较</span></span><br><span class="line">    <span class="keyword">return</span> p != <span class="literal">NULL</span>;<span class="comment">//如果p为空，没找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(Node *node)</span> </span>&#123; <span class="comment">// 清空ｎｏｄｅ</span></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    Node *p = node, *q; </span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p-&gt;str);</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_hashtablie</span><span class="params">(HashTable *h)</span> </span>&#123;<span class="comment">// 释放哈希表</span></span><br><span class="line">    <span class="keyword">if</span>(h == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h-&gt;size; i++) clear_node(h-&gt;data[i]);<span class="comment">//对哈希表上每一个链表释放</span></span><br><span class="line">    <span class="built_in">free</span>(h-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(h);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_n 100</span></span><br><span class="line">    <span class="keyword">char</span> str[max_n + <span class="number">5</span>];</span><br><span class="line">    HashTable *h = init_hashtable(max_n + <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;op, str)) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"insert %s to hash table\n"</span>, str);</span><br><span class="line">            insert(h, str);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"search %s from hash table tesult = %d\n"</span>, str, search(h, str));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clear_hashtablie(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="９-二叉排序树"><a href="#９-二叉排序树" class="headerlink" title="９.二叉排序树"></a>９.二叉排序树</h2><p>二叉查找树的插入和查找效率相对较高，最坏情况下时间复杂度为  <code>O(n)</code>，期望的时间复杂度为 <em><code>o(logn)</code></em>，其中 <code>n</code>为树上结点总个数。<br>二叉查找树的基础上可以加些优化，可以让其成为 <code>AVL</code>树，红黑树，<code>SBT</code>，<code>Splay</code><br><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex078fs1rj30kv0ayacc.jpg" alt="2020-02-22 16-04-18屏幕截图.png"><br>当中序遍历后他是个有序的数列，解决检索与排名</p>
<h5 id="插入"><a href="#插入" class="headerlink" title="插入:"></a><font color = red>插入:</font></h5><p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex07illiuj30kx094ta6.jpg" alt="2020-02-22 16-11-03屏幕截图.png"><br>10从头小于20往左走，小于17继续，大于3往右走：<br><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex07sojwyj30kt09d0uj.jpg" alt="2020-02-22 16-12-56屏幕截图.png"></p>
<ol>
<li>根节点为空则新元素直接作为根节点，否则传入的参数 value 与根节点进行比较。</li>
<li>value 等于当前节点则直接返回，小于则跳转到步骤 3，而如果 value 大于当前节点时，跳转到步骤 4。</li>
<li>判断当前节点是否存在左孩子，如果存在则让其左孩子继续调用插入方法，回到步骤 2，如果不存在则将新元素插入到当前节点的左孩子位置上。</li>
<li>判断当前节点是否存在右孩子，存在则让其右子树继续调用插入方法，回到步骤 2，不存在则将新元素插入到当前节点的右孩子位置上。</li>
</ol>
<p><img src="https://res.jisuanke.com/img/upload/20161121/1d834bcad7f92b2202c9a67633f78028947f7b29.gif" alt="img">插入一个值为８的元素</p>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除:"></a><font color = red>删除:</font></h5><ol>
<li>找到当前节点的左孩子，如果当前节点没有左孩子则不存在前驱，若存在，则找到其左孩子的右孩子。</li>
<li>若当前节点有右孩子则继续找到其右孩子，重复步骤 2，直至找到一个节点不存在右孩子时，那么它就是我们要查找的前驱。<ol>
<li>如果当前节点仅存在左孩子，则更新左孩子的父节点为被删除节点的父节点。</li>
<li>如果当前节点仅存在右孩子，则将其右孩子的父节点更新为被删除节点的父节点。</li>
<li>更新被删除节点的父节点的孩子指针，使其原本指向被删除节点的指针指向被删除节点的孩子节点。</li>
</ol>
</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex081sa49j30l009fgnn.jpg" alt="2020-02-22 16-15-47屏幕截图.png"><br>１．删除叶子节点:直接删除<br>２．删除出度为１的节点:<br><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex08cgq9gj30l509dwgp.jpg" alt="2020-02-22 16-16-25屏幕截图.png"><br>提升３的唯一子树<br>３．删除度为２的结点：<br><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex08lrdpmj30kl09bju3.jpg" alt="2020-02-22 16-22-58屏幕截图.png"><br>找到前驱或者是后继替换掉，转换为度为１（０）的结点问题，<br>前驱为左边最大值，后继为右边的最小值<br>[17 18 19 20 28 29 30 32]<br>此处删除的时候先将19覆盖20然后删除19;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="comment">//结构定义二叉树</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;key = key;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123; <span class="comment">//插入</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> getNewNode(key);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;key == key) <span class="keyword">return</span> root;<span class="comment">//如果插入的值等于根，插入失败</span></span><br><span class="line">    <span class="keyword">if</span>(key &lt; root-&gt;key) root-&gt;lchild = insert(root-&gt;lchild, key);<span class="comment">//如果插入的值小于root往左插入</span></span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insert(root-&gt;rchild, key);<span class="comment">//如果插入的值大于root往右递归插入</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123; <span class="comment">//找到前驱，就是左子树的最右结点</span></span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;rchild)temp = temp -&gt; rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123; <span class="comment">// 删除结点</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span>(key &lt; root-&gt;key) root-&gt;lchild = erase(root-&gt;lchild, key); <span class="comment">//如果删除的值小于root那么向左递归找到删除</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; root-&gt;key) root-&gt;rchild = erase(root-&gt;rchild, key);<span class="comment">//如果删除的值大于往右走</span></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//如果找到的话</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;lchild == <span class="literal">NULL</span> || root-&gt;rchild == <span class="literal">NULL</span>) &#123; <span class="comment">//如果度为１或０</span></span><br><span class="line">            Node *temp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild; <span class="comment">//建立一个中间变量记录左右结点，０度结点记录空</span></span><br><span class="line">            <span class="built_in">free</span>(root);<span class="comment">//释放此节点</span></span><br><span class="line">            <span class="keyword">return</span> temp;<span class="comment">//返回记录的他的左孩子还是右孩子</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//如果删除的度为２</span></span><br><span class="line">            Node *temp = predecessor(root);<span class="comment">//找到左子树最大的一个接点，也就是最右边的一个节点</span></span><br><span class="line">            root-&gt;key = temp-&gt;key; <span class="comment">//将它赋值给根</span></span><br><span class="line">            root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;key); <span class="comment">// 然后从根把其左子树给递归删除释放掉</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;<span class="comment">//返回结点；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __in_order(Node *root) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    __in_order(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;key);</span><br><span class="line">    __in_order(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"in_order output : "</span>);</span><br><span class="line">    __in_order(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> op, val;</span><br><span class="line">     Node *root = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">         <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">1</span>: root = insert(root, val);<span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">2</span>: root = erase(root, val);<span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         in_order(root);</span><br><span class="line">     &#125;</span><br><span class="line">     clear(root);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex08yi51hj30d500vt8r.jpg" alt="2020-02-22 16-36-15屏幕截图.png"></p>
<h2 id="10-森林与并查集"><a href="#10-森林与并查集" class="headerlink" title="10.森林与并查集"></a>10.森林与并查集</h2><p><strong>连通性问题</strong><br>1.基于<font color = red>染色</font>思想，一开始所有的点不同颜色<br>2.连接两个点的操作，可以看成<font color = blue>一种颜色</font>的点染成<font color = green>另一种颜色</font><br>3.如果两个点颜色一样，证明联通，否则不连通<br>4.这种方法叫做并查集的：【Quick-Find算法】</p>
<h5 id="QUICK-FIND算法"><a href="#QUICK-FIND算法" class="headerlink" title="QUICK-FIND算法"></a>QUICK-FIND算法</h5><p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex09bdqjhj30lb0andh3.jpg" alt="2020-02-22 18-24-51屏幕截图.png"><br>1.联通判断：O(1)<br>2.合并操作：O(n)<br><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex09inph7j30hd03rmyz.jpg" alt="2020-02-22 18-30-59屏幕截图.png"></p>
<p>quick-find :</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">UnionSet</span> &#123;</span> <span class="comment">//结构定义颜色和个数ｎ</span></span><br><span class="line">    <span class="keyword">int</span> *color;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;UnionSet;</span><br><span class="line"></span><br><span class="line"><span class="function">UnionSet *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">    UnionSet *u = (UnionSet *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(UnionSet));</span><br><span class="line">    u-&gt;color = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    u-&gt;n = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">//将其数组color每个值赋值为ｉ</span></span><br><span class="line">        u-&gt;color[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(UnionSet *u, <span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//寻找x对应的颜色</span></span><br><span class="line">    <span class="keyword">return</span> u-&gt;color[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(UnionSet *u, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">//合并两种颜色</span></span><br><span class="line">    <span class="keyword">if</span>(find(u, a) == find(u, b)) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果两种颜色相同则不进行合并</span></span><br><span class="line">    <span class="keyword">int</span> color_a = u-&gt;color[a];  <span class="comment">//先记录一下颜色ａ</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= u-&gt;n; i++) &#123; <span class="comment">// 将所有与ａ相同颜色的设置成ｂ的颜色；</span></span><br><span class="line">        <span class="keyword">if</span>(u-&gt;color[i] != color_a) <span class="keyword">continue</span>;</span><br><span class="line">        u-&gt;color[i] = u-&gt;color[b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(UnionSet *u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(u-&gt;color);</span><br><span class="line">    <span class="built_in">free</span>(u);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    UnionSet *u = init(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a ,&amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:merge(u, b, c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, find(u, b) == find(u, c) ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clear(u);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>—————————————-下一个优化算法———————————–</p>
<h5 id="QUICK-UNION算法"><a href="#QUICK-UNION算法" class="headerlink" title="QUICK-UNION算法"></a>QUICK-UNION算法</h5><p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex09ublw7j30lu0aztau.jpg" alt="2020-02-22 18-39-50屏幕截图.png"><br><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex0a7svt3j30l708840u.jpg" alt="2020-02-22 19-08-10屏幕截图.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex0amd7tlj30jt06rmz2.jpg" alt="2020-02-22 22-01-54屏幕截图.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">UnionSet</span> &#123;</span> <span class="comment">// 结构定义,父亲和个数</span></span><br><span class="line">    <span class="keyword">int</span> *father;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;UnionSet;</span><br><span class="line"></span><br><span class="line"><span class="function">UnionSet *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 初始化</span></span><br><span class="line">    UnionSet *u = (UnionSet *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(UnionSet));</span><br><span class="line">    u-&gt;father = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    u-&gt;n = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//将每一个父节点设置成自己</span></span><br><span class="line">        u-&gt;father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(UnionSet *u, <span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 查找ｘ的父亲是否是自己，知道查找到</span></span><br><span class="line">    <span class="keyword">if</span>(u-&gt;father[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> find(u, u-&gt;father[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(UnionSet *u, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">//合并</span></span><br><span class="line">    <span class="keyword">int</span> fa = find(u ,a), fb = find(u, b);<span class="comment">//找到ａ的父亲，找到ｂ的父亲</span></span><br><span class="line">    <span class="keyword">if</span>(fa == fb) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果同父亲不执行</span></span><br><span class="line">    u-&gt;father[fa] = fb;<span class="comment">//将ｂ子树合并到ａ</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(UnionSet *u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(u-&gt;father);</span><br><span class="line">    <span class="built_in">free</span>(u);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    UnionSet *u = init(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a ,&amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:merge(u, b, c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, find(u, b) == find(u, c) ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clear(u);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="WEIGHTED-QYICK-UNION算法"><a href="#WEIGHTED-QYICK-UNION算法" class="headerlink" title="WEIGHTED QYICK-UNION算法"></a>WEIGHTED QYICK-UNION算法</h5><p>优化：树低的连树高的上面，时间复杂度由<code>O(n)</code><font color = red>-&gt;</font><code>O(logn)</code>;</p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex0b1fgojj311k0lgag4.jpg" alt="2020-02-22 19-38-44屏幕截图.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex0bb55auj31010nf437.jpg" alt="2020-02-22 19-45-42屏幕截图.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex0blig7qj316p0jtage.jpg" alt="2020-02-22 19-55-11屏幕截图.png"></p>
<p>说明节点个数小的适合作为子树进行合并</p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex0bxtwozj30lm0axjtz.jpg" alt="2020-02-22 19-57-43屏幕截图.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex0cby7ujj30jm06p0un.jpg" alt="2020-02-22 22-02-50屏幕截图.png"></p>
<p>路径压缩：将０指向３<br><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex0ckeliij30l8076jt8.jpg" alt="2020-02-22 20-05-45屏幕截图.png"><br><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex0duzrn1j30l307qwgs.jpg" alt="2020-02-22 20-09-15屏幕截图.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123;\</span></span><br><span class="line">    __typeof(a) __temp = a;\</span><br><span class="line">    a = b; b = __temp;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">UnionSet</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *father, *size;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;UnionSet;</span><br><span class="line"></span><br><span class="line"><span class="function">UnionSet *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    UnionSet *u = (UnionSet *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(UnionSet));</span><br><span class="line">    u-&gt;father = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    u-&gt;size = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    u-&gt;n = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        u-&gt;father[i] = i;</span><br><span class="line">        u-&gt;size[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(UnionSet *u, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u-&gt;father[x] = (u-&gt;father[x] == x ? x : find(u, u-&gt;father[x])); <span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(UnionSet *u, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = find(u ,a), fb = find(u, b);</span><br><span class="line">    <span class="keyword">if</span>(fa == fb) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(u-&gt;size[fa] &lt; u-&gt;size[fb])swap(fa, fb); <span class="comment">//交换后ｂ作子树</span></span><br><span class="line">    u-&gt;father[fa] = fb;</span><br><span class="line">    u-&gt;size[fa] += u-&gt;size[fb];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int merge(UnionSet *u, int a, int b) &#123;</span></span><br><span class="line"><span class="comment">    int fa = find(u ,a), fb = find(u, b);</span></span><br><span class="line"><span class="comment">    if(fa == fb) return 0;</span></span><br><span class="line"><span class="comment">    if(u-&gt;size[fa] &gt; u-&gt;size[fb]) &#123; // 如果ｂ的结点少于ａ，则ｂ作子树</span></span><br><span class="line"><span class="comment">    u-&gt;father[fb] = fa;</span></span><br><span class="line"><span class="comment">    u-&gt;size[fa] += u-&gt;size[fb];</span></span><br><span class="line"><span class="comment">    &#125; else &#123;　// 反之</span></span><br><span class="line"><span class="comment">    u-&gt;father[fa] = fb;</span></span><br><span class="line"><span class="comment">    u-&gt;size[fb] += u-&gt;size[fa];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return 1;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(UnionSet *u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(u-&gt;father);</span><br><span class="line">    <span class="built_in">free</span>(u-&gt;size);</span><br><span class="line">    <span class="built_in">free</span>(u);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    UnionSet *u = init(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a ,&amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:merge(u, b, c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, find(u, b) == find(u, c) ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clear(u);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gex0e7zknnj30cw02gwfb.jpg" alt="2020-02-22 20-10-09屏幕截图.png"></p>
<h2 id="11-字符串匹配"><a href="#11-字符串匹配" class="headerlink" title="11.字符串匹配"></a>11.字符串匹配</h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*暴力*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brute_force</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> len2 = <span class="built_in">strlen</span>(t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, I = len1 - len2 + <span class="number">1</span>;i&lt;I; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; t[j]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t[j] == s[i + j])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!t[j]) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*KMP*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> len2 = <span class="built_in">strlen</span>(t);</span><br><span class="line">    <span class="keyword">int</span> *next = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len2);</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">-1</span>; i &lt; len2; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">-1</span> &amp;&amp; t[j + <span class="number">1</span>] != t[i]) j = next[j];</span><br><span class="line">        <span class="keyword">if</span>(t[j + <span class="number">1</span>] == t[i]) j+=<span class="number">1</span>;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">-1</span> &amp;&amp; t[j + <span class="number">1</span>] != s[i]) j = next[j];</span><br><span class="line">        <span class="keyword">if</span>(t[j + <span class="number">1</span>] == s[i]) j += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[j + <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">return</span> i - len2 + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sunday"><a href="#sunday" class="headerlink" title="sunday"></a>sunday</h3><p>主要是黄金堆起点位</p>
<p>最优时间算法复杂度n / m;</p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gf0g1y9i62j30j707htbw.jpg" alt="image.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gf0g2jk6psj30jj07pgpb.jpg" alt="image.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gf0g2ugpegj30jo078n07.jpg" alt="image.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gf0g349d5nj30k107ktcc.jpg" alt="image.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gf0g4xr2zcj30k907kn0y.jpg" alt="image.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gf0g57kib3j30kw07a77k.jpg" alt="image.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gf0g5yhmwlj30l407v780.jpg" alt="image.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*sunday*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sunday</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ind[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> len2 = <span class="built_in">strlen</span>(t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) ind[i] = len2 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; t[i]; i++) ind[t[i]] = len2 - i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, I = len1 - len2 + <span class="number">1</span>; i &lt; I; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t[j] == s[i + j]) <span class="keyword">continue</span>;</span><br><span class="line">            i += ind[s[i + len2]];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="shift-and"><a href="#shift-and" class="headerlink" title="shift_and"></a>shift_and</h3><p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gf07afogpkj30fr06cwgm.jpg" alt="image.png"></p>
<p><img src="../../../.config/Typora/typora-user-images/image-20200521173052961.png" alt="image-20200521173052961"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*shift_and*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shift_and</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> code[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(len = <span class="number">0</span>; t[len]; len++) &#123;</span><br><span class="line">        code[t[len]] |= (<span class="number">1</span> &lt;&lt; len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        p = (p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &amp; code[s[i]];</span><br><span class="line">        <span class="keyword">if</span>(p &amp; (<span class="number">1</span> &lt;&lt; (len - <span class="number">1</span>)))<span class="keyword">return</span> i - len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="12-树状数组"><a href="#12-树状数组" class="headerlink" title="12. 树状数组"></a>12. 树状数组</h2><p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gf3l52rx9xj31cn0swn9t.jpg" alt="image.png"></p>
<p><code>C6 = a6 + a5     6=110   最低位权2</code></p>
<p><code>C7 = a7              7=111   最低位权1</code></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gf3l77xnmfj30tq0f50we.jpg" alt="image.png"></p>
<p>6 + lowbit(6)包含C6</p>
<p>5 + lowbit(5) 包含c5</p>
<p>i-&gt;i+lowbit(i)</p>
<p>log<sub>2</sub>n</p>
<p><img src="https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181003121208845-81274925.png" alt="img"></p>
<ul>
<li><p>C[1] = A[1];</p>
</li>
<li><p>C[2] = A[1] + A[2];</p>
</li>
<li><p>C[3] = A[3];</p>
</li>
<li><p>C[4] = A[1] + A[2] + A[3] + A[4];</p>
</li>
<li><p>C[5] = A[5];</p>
</li>
<li><p>C[6] = A[5] + A[6];</p>
</li>
<li><p>C[7] = A[7];</p>
</li>
<li><p>C[8] = A[1] + A[2] + A[3] + A[4] + A[5] + A[6] + A[7] + A[8];</p>
<p><img src="https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181003121604644-268531484.png" alt="img"></p>
</li>
</ul>
<p>相比传统的前缀和单点修改时间复杂度是log级别，但是求区间和也是log,而传统是O(1)的</p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gf4vvr41toj30hs05340o.jpg" alt="image.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gf4vwa4t0aj30ki0bin1u.jpg" alt="image.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gf4vwr592bj30lw0bx79v.jpg" alt="image.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gf4vx0nohwj30l30bxwkn.jpg" alt="image.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006Uqzbtly1gf4vxlog8oj30kh0buaeg.jpg" alt="image.png"></p>
<p><strong>如果在做题中突然出现一个求累加和就往树状数组上想</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX_N 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="keyword">int</span> c[MAX_N + <span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> val, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n) c[i] += val, i += lowbit(i);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">S</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i)sum += c[i], i -= lowbit(i);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, a;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        add(i, a, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; S(i) - S(i - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong s>
              本博客所有文章除特别声明外，均采用 <a href="https://www.apache.org/licenses/LICENSE-2.0.html" rel="external nofollow"
                target="_blank">Apache License 2.0</a> 许可协议。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://yoursite.com/2020/05/29/Mynotes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      

    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/05/29/Mynotes/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%9A%84%E5%8F%98%E5%BD%A2/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Mynotes/算法/线性筛的变形
          
        </div>
      </a>
    
    
      <a href="/2020/05/29/Mynotes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/UDP%E7%BC%96%E7%A8%8B/%E4%BD%BF%E7%94%A8UDP%E7%BC%96%E7%A8%8B/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Mynotes/操作系统与系统编程/UDP编程/使用UDP编程</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: '',
        app_key: '',
        path: window.location.pathname,
        notify: 'false',
        verify: 'false',
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        fangsong
      </li>
      <li>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="恁村扛把子"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>

<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>



<script src="/js/tocbot.min.js"></script>
<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>



<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>
<script src="/dist/main.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>



<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

  <script src="/js/clickLove.js"></script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=436514312&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>